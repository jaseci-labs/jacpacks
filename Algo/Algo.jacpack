{
  "name": "algo",
  "description": "Voice RAG Application built with Jac and OpenAI Realtime API",
  "config": {
    "project": {
      "name": "voice-rag-jac",
      "version": "1.0.0",
      "description": "Voice RAG Application built with Jac and OpenAI Realtime API",
      "entry-point": "src/app.jac",
      "author": "Jaseci Team"
    },
    "serve": {
      "base_route_app": "app"
    },
    "plugins": {
      "client": {
        "vite": {
          "plugins": [
            "tailwindcss()"
          ],
          "lib_imports": [
            "import tailwindcss from '@tailwindcss/vite'"
          ]
        }
      },
      "scale": {
        "kubernetes": {
          "app_name": "algo-test",
          "namespace": "algo-test"
        }
      }
    },
    "dependencies": {
      "npm": {
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "react-router-dom": "^6.22.0",
        "react-error-boundary": "^4.0.0",
        "@openai/agents": "latest",
        "zod": "^4.0.0",
        "@hpcc-js/wasm": "latest",
        "@tailwindcss/vite": "^4.1.17",
        "clsx": "^2.1.1",
        "tailwind-merge": "^3.4.0",
        "tailwindcss": "^4.1.17",
        "dev": {
          "vite": "^6.4.1",
          "@babel/cli": "^7.28.3",
          "@babel/core": "^7.28.5",
          "@babel/preset-env": "^7.28.5",
          "@babel/preset-react": "^7.28.5",
          "@vitejs/plugin-react": "^4.2.1",
          "typescript": "^5.3.3",
          "@types/react": "^18.2.0",
          "@types/react-dom": "^18.2.0"
        }
      }
    }
  },
  "files": {
    "main.jac": "import from service.mainAppService {\n    get_session_token,\n    init_user_graph,\n    update_task_graph,\n    get_task_graph,\n    clear_graph,\n    save_routine,\n    load_past_routines,\n    reset_session,\n    rebuild_graph,\n    rename_task,\n    call_manager\n}\n\ncl import from .index { app as ClientApp }\n\n\ncl {\n    def:pub app() -> any {\n        return <ClientApp />;\n    }\n}",
    "global.css": "@import \"tailwindcss\";\n@source \".\";\n\n@theme {\n  /* Brand */\n  --color-primary: #ff7743;\n  --color-primary-foreground: #ffffff;\n\n  --color-secondary: #273f4f;\n  --color-secondary-foreground: #ffffff;\n\n  /* Backgrounds */\n  --color-background: #f0eeea;\n  --color-surface: #ffffff;\n  --color-surface-hover: #f5f5f5;\n\n  /* Text */\n  --color-text-primary: #273f4f;\n  --color-text-secondary: #6f7173;\n\n  /* Borders */\n  --color-border: #dadada;\n\n  /* Utility */\n  --color-black: #000000;\n\n  /* Console/Terminal */\n  --color-console: #1e1e1e;\n  --color-console-text: #d4d4d4;\n\n  /* Semantic Colors */\n  --color-success: #4caf50;\n  --color-success-foreground: #ffffff;\n  --color-warning: #ff9800;\n  --color-warning-foreground: #000000;\n  --color-error: #f44336;\n  --color-error-foreground: #ffffff;\n}\n\n/* Dark Mode */\n.dark {\n  --color-primary: #ff8a5c;\n  --color-primary-foreground: #ffffff;\n\n  --color-secondary: #4a6b7c;\n  --color-secondary-foreground: #ffffff;\n\n  /* Backgrounds */\n  --color-background: #1a1a1a;\n  --color-surface: #252525;\n  --color-surface-hover: #2d2d2d;\n\n  /* Text */\n  --color-text-primary: #e5e5e5;\n  --color-text-secondary: #a0a0a0;\n\n  /* Borders */\n  --color-border: #3d3d3d;\n\n  /* Console/Terminal */\n  --color-console: #0d0d0d;\n  --color-console-text: #d4d4d4;\n\n  /* Semantic Colors - slightly brighter for dark mode */\n  --color-success: #66bb6a;\n  --color-success-foreground: #000000;\n  --color-warning: #ffb74d;\n  --color-warning-foreground: #000000;\n  --color-error: #ef5350;\n  --color-error-foreground: #ffffff;\n}\n\n/* Scrollbar styling */\n::-webkit-scrollbar {\n  width: 8px;\n  height: 8px;\n}\n\n::-webkit-scrollbar-track {\n  @apply bg-surface-hover;\n}\n\n::-webkit-scrollbar-thumb {\n  @apply bg-text-secondary rounded;\n}\n\n::-webkit-scrollbar-thumb:hover {\n  @apply bg-text-primary;\n}\n\n.dark ::-webkit-scrollbar-track {\n  @apply bg-surface;\n}\n\n.dark ::-webkit-scrollbar-thumb {\n  @apply bg-border;\n}\n\n.dark ::-webkit-scrollbar-thumb:hover {\n  @apply bg-text-secondary;\n}\n",
    "index.cl.jac": "# Note: React imports removed - hooks use 'has' for state management\nimport from \"@jac/runtime\" { Router, Routes, Route }\n\nimport from .pages.MainApp { MainApp }\nimport from .pages.HomePage { HomePage }\nimport from .pages.LoginPage { LoginPage }\nimport from .pages.RegisterPage { RegisterPage }\n\n\nimport from .utils.ProtectedRoute { ProtectedRoute }\nimport \".global.css\";\n\n# Main App with Router\ndef:pub app() -> any {\n    return <Router>\n        <Routes>\n            <Route path=\"/\" element={<HomePage />} />\n            <Route path=\"/login\" element={<LoginPage />} />\n            <Route path=\"/register\" element={<RegisterPage />} />\n            <Route\n                path=\"/app\"\n                element={\n                    <ProtectedRoute>\n                        <MainApp />\n                    </ProtectedRoute>\n                }\n            />\n        </Routes>\n    </Router>;\n}",
    "README.md": "# Algo - Voice-Enabled Task Graph Assistant\n\nAlgo is a voice-enabled personal AI assistant that helps you visualize and manage your daily routines as an interactive task graph. Using the OpenAI Realtime API for voice interactions, Algo understands your intent and automatically builds, validates, and maintains a directed graph of your tasks and routines.\n\n## Features\n\n- \ud83c\udf99\ufe0f **Voice Interface** - Natural conversations via OpenAI Realtime API\n- \ud83d\udcca **Task Graph Visualization** - Interactive directed graph showing your routines\n- \ud83e\udd16 **Multi-Agent Architecture** - Manager supervises Graph Agent with intelligent validation\n- \u2705 **Automatic Corrections** - Detects and fixes missing tasks, wrong names, and incorrect edge labels\n- \ud83d\udd04 **Graph Operations** - Rename tasks, insert between tasks, reorder routines\n- \ud83d\udcbe **Routine Persistence** - Save and load your daily routines\n- \ud83d\udd10 **Authentication** - Secure login/register system\n\n## Installation\n\n1. **Clone the repository**\n   ```bash\n   git clone https://github.com/jaseci-labs/Algo.git\n   cd Algo\n   ```\n\n2. **Set up your API key**\n\n   Create a `.env` file or set environment variable:\n   ```bash\n   export OPENAI_API_KEY='your-api-key-here'\n   ```\n\n3. **Start the application**\n   ```bash\n   jac start main.jac\n   ```\n\n4. **Open your browser**\n\n   Navigate to http://localhost:8000\n\n## Authentication\n\n- **Register**: Create a new account at `/register`\n- **Login**: Access your account at `/login`\n- **Main App**: Protected route at `/app` requires authentication\n\n## Architecture\n\nAlgo uses a **Manager \u2192 Graph Agent** multi-agent hierarchy:\n\n```\nUser \u2192 call_manager \u2192 call_graph_agent\n                      \u2193\n                validate_graph_output\n                      \u2193\n                (stores validation result)\n                      \u2193\n                Graph Agent corrects/reports\n```\n\n### Manager Agent\n- Supervises and validates the Graph Agent's output\n- Ensures user messages are correctly interpreted\n- Handles corrections when Graph Agent fails\n- **Silent validator** - never sends responses directly to users\n\n### Graph Agent\n- Analyzes conversation intent using LLM semantic functions\n- Extracts task names and builds graph relationships\n- Updates the task graph with nodes (TaskState) and edges (TaskFlow)\n- Performs corrections based on Manager validation feedback\n\n### Validation System\n\nThe Manager validates multiple operation types:\n\n| Operation | Description |\n|-----------|-------------|\n| **Task Extraction** | Ensures all tasks mentioned are captured |\n| **Task Rename** | Validates task renames (old task removed, new task correct) |\n| **Insert** | Validates task insertion position (before/after/between) |\n| **Reorder** | Validates task reordering (no circular refs, correct order) |\n| **Edge Labels** | Validates edge labels match user intent (conditional, parallel, sequential) |\n\n### Supported Operations\n\n- **Rename**: \"rename `MakeCoffee` to `GrabCoffee`\"\n- **Insert Before**: \"insert `WashFace` before `CheckMessages`\"\n- **Insert After**: \"insert `HaveBreakfast` after `MakeCoffee`\"\n- **Reorder**: \"have coffee before checking news\"\n- **Conditional**: \"if raining, read book; otherwise, walk\"\n- **Parallel**: \"have drink while chatting with buddies\"\n\n### Edge Label Rules\n\n| Pattern | Label |\n|---------|-------|\n| Sequential (default) | `\"then\"`, `\"afterwards\"` |\n| Parallel tasks | `\"while\"`, `\"at same time\"` |\n| Conditional branches | `\"if X\"`, `\"otherwise\"` |\n| Conditional convergence | `\"either way\"` |\n| Parallel convergence | `\"then\"`, `\"afterwards\"` |\n\n## Project Structure\n\n```\nAlgo/\n\u251c\u2500\u2500 main.jac                    # Entry point\n\u251c\u2500\u2500 service/\n\u2502   \u251c\u2500\u2500 mainAppService.jac     # Service layer definition\n\u2502   \u2514\u2500\u2500 mainAppService.impl.jac # Implementation (Graph Agent, Manager, helpers)\n\u251c\u2500\u2500 semantics/\n\u2502   \u2514\u2500\u2500 semantics.jac           # LLM semantic functions (intent, extraction, validation)\n\u251c\u2500\u2500 api/\n\u2502   \u2514\u2500\u2500 api.cl.jac              # Frontend API endpoints\n\u251c\u2500\u2500 hooks/\n\u2502   \u2514\u2500\u2500 useMainApp.cl.jac       # React composition hooks\n\u251c\u2500\u2500 pages/\n\u2502   \u251c\u2500\u2500 MainApp.cl.jac          # Main app interface\n\u2502   \u251c\u2500\u2500 LoginPage.cl.jac        # Login page\n\u2502   \u2514\u2500\u2500 RegisterPage.cl.jac     # Registration page\n\u2514\u2500\u2500 components/\n    \u2514\u2500\u2500 GraphViewer.cl.jac      # Graph visualization component\n```\n\n## Development\n\n```bash\n# Install dependencies\npip install jaclang jac-client jac-scale byllm\n\n# Run locally\njac start \n\n# Deploy to Kubernetes\njac start main.jac --scale\n```\n\n## License\n\nMIT",
    "=0.9.11": "Collecting jaclang\n  Downloading jaclang-0.9.11-py3-none-any.whl.metadata (5.0 kB)\nDownloading jaclang-0.9.11-py3-none-any.whl (5.5 MB)\n   \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 5.5/5.5 MB 26.7 MB/s  0:00:00\nInstalling collected packages: jaclang\nSuccessfully installed jaclang-0.9.11\n",
    "api/api.cl.jac": "# mainAppService - Service Layer for MainApp\n# Centralizes all root spawn API calls for better reusability and maintainability\n# This service layer abstracts backend communication from UI components\n\n# ============================================\n# Graph Service\n# ============================================\n\n# Fetch the task graph for a specific user\n# @param username - The username to fetch the graph for\n# @returns Graph data containing dotCode, edges, and lastTask\nasync def:pub getTaskGraph(username: str) -> any {\n        try {\n            response = root spawn get_task_graph(username=username);\n            \n            if response and response.reports and response.reports.length > 0 {\n                return {\n                    \"success\": True,\n                    \"data\": response.reports[0]\n                };\n            }\n            \n            return {\n                \"success\": False,\n                \"error\": \"No data returned from get_task_graph\"\n            };\n        } except Exception as e {\n            console.error(\"getTaskGraph error:\", e);\n            return {\n                \"success\": False,\n                \"error\": String(e)\n            };\n        }\n    }\n\n# Clear the task graph for a specific user\n# @param username - The username whose graph should be cleared\n# @returns Success status and cleared graph data\nasync def:pub clearTaskGraph(username: str) -> any {\n    try {\n        clearResponse = root spawn clear_graph(username=username);\n        clearResult = clearResponse.reports[0] if clearResponse.reports else {};\n        \n        if clearResult and clearResult.success {\n            # Fetch the updated (empty) graph state\n            graphResponse = root spawn get_task_graph(username=username);\n            graphData = graphResponse.reports[0] if graphResponse.reports else {};\n            \n            return {\n                \"success\": True,\n                \"data\": {\n                    \"dotCode\": graphData.dotCode or \"\",\n                    \"edges\": graphData.edges or [],\n                    \"lastTask\": graphData.lastTask or \"Start\"\n                }\n            };\n        }\n        \n        return {\n            \"success\": False,\n            \"error\": clearResult.error if clearResult and clearResult.error else \"Failed to clear graph\"\n        };\n    } except Exception as e {\n        console.error(\"clearTaskGraph error:\", e);\n        return {\n            \"success\": False,\n            \"error\": String(e)\n        };\n    }\n}\n\n\n# ============================================\n# Session Service\n# ============================================\n\n# Fetch ephemeral session token for OpenAI Realtime API\n# @returns The ephemeral API key or None if failed\nasync def:pub getSessionToken() -> any {\n    try {\n        response = root spawn get_session_token();\n        data = response.reports[0] if response.reports else None;\n        \n        if data and \"error\" in data {\n            console.error(\"Error fetching session:\", data);\n            return {\n                \"success\": False,\n                \"error\": data.error or \"Session token error\"\n            };\n        }\n        \n        if data and \"key\" in data {\n            return {\n                \"success\": True,\n                \"key\": data.key\n            };\n        }\n        \n        return {\n            \"success\": False,\n            \"error\": \"No key returned from get_session_token\"\n        };\n    } except Exception as e {\n        console.error(\"getSessionToken error:\", e);\n        return {\n            \"success\": False,\n            \"error\": String(e)\n        };\n    }\n}\n\n\n# ============================================\n# Supervisor Service\n# ============================================\n\n# Call the supervisor agent with conversation context\n# @param context_from_user - The relevant context from user's message\n# @param conversation_history - Array of conversation history items\n# @param username - The current user's username\n# @returns Manager response with nextResponse or error\nasync def:pub callManager(context_from_user: str, conversation_history: list, username: str) -> any {\n    try {\n        result = root spawn call_manager(\n            conversation_history=conversation_history,\n            context_from_user=context_from_user,\n            username=username\n        );\n\n        response_data = result.reports[result.reports.length - 1] if result.reports and result.reports.length > 0 else {};\n\n        if response_data and \"error\" in response_data {\n            console.error(\"Manager error:\", response_data);\n            return {\n                \"success\": False,\n                \"error\": response_data.error or \"Manager error\"\n            };\n        }\n\n        # Extract response\n        next_resp = \"\";\n        if \"response\" in response_data {\n            next_resp = response_data[\"response\"];\n        } else {\n            next_resp = \"I apologize, I couldn't get a response.\";\n        }\n\n        # Extract suggestions if available\n        suggestions = [];\n        if \"suggestions\" in response_data {\n            suggestions = response_data[\"suggestions\"];\n        }\n\n        # Extract thinking insights if available\n        thinking = None;\n        if \"thinking\" in response_data {\n            thinking = response_data[\"thinking\"];\n        }\n\n        return {\n            \"success\": True,\n            \"response\": next_resp,\n            \"suggestions\": suggestions,\n            \"thinking\": thinking,\n            \"data\": response_data\n        };\n    } except Exception as e {\n        console.error(\"callManager error:\", e);\n        return {\n            \"success\": False,\n            \"error\": String(e)\n        };\n    }\n}\n\n# Legacy function - redirects to callManager for backward compatibility\nasync def:pub callSupervisor(context_from_user: str, conversation_history: list, username: str) -> any {\n    return await callManager(context_from_user, conversation_history, username);\n}\n# Send a text message to the supervisor (simplified version for text-only mode)\n# @param message - The user's message\n# @param username - The current user's username\n# @returns Supervisor response\nasync def:pub sendTextMessage(message: str, username: str) -> any {\n    return await callSupervisor(\n        context_from_user=message,\n        conversation_history=[],\n        username=username\n    );\n}\n\n\n# ============================================\n# Routine Service\n# ============================================\n\n# Save the current routine for a user\n# @param routine_name - Name of the routine to save\n# @param username - The current user's username\n# @returns Success status and any error message\nasync def:pub saveRoutine(routine_name: str, username: str) -> any {\n    try {\n        saveResponse = root spawn save_routine(routine_name=routine_name, username=username);\n        saveResult = saveResponse.reports[0] if saveResponse.reports else {};\n        \n        if saveResult and saveResult.success {\n            return {\n                \"success\": True,\n                \"data\": saveResult\n            };\n        }\n        \n        return {\n            \"success\": False,\n            \"error\": saveResult.error if saveResult and saveResult.error else \"Failed to save routine\"\n        };\n    } except Exception as e {\n        console.error(\"saveRoutine error:\", e);\n        return {\n            \"success\": False,\n            \"error\": String(e)\n        };\n    }\n}\n\n# Save the default daily routine\n# @param username - The current user's username\n# @returns Success status\nasync def:pub saveDailyRoutine(username: str) -> any {\n    return await saveRoutine(routine_name=\"daily_routine\", username=username);\n}\n\n\n# ============================================\n# Utility Functions\n# ============================================\n\n# Extract username from JWT token stored in localStorage\n# @returns Username string or \"anonymous\" if not found\ndef:pub getUsernameFromToken() -> str {\n    token = localStorage.getItem(\"jac_token\");\n    username = \"anonymous\";\n    if token {\n        try {\n            parts = token.split(\".\");\n            if parts.length > 1 {\n                payload = JSON.parse(atob(parts[1]));\n                username = payload.username or \"anonymous\";\n            }\n        } except Exception as decode_error {\n            console.error(\"Failed to decode token:\", decode_error);\n        }\n    }\n    return username;\n}\n\n# Check if user is authenticated\n# @returns True if user has a valid token\ndef:pub isAuthenticated() -> bool {\n    token = localStorage.getItem(\"jac_token\");\n    return token != None and token != \"\";\n}\n",
    "utils/ProtectedRoute.cl.jac": "import from \"@jac/runtime\" { jacIsLoggedIn, Navigate }\n\ndef:pub ProtectedRoute(props: any) -> any {\n    if not jacIsLoggedIn() {\n        return <Navigate to=\"/login\" />;\n    }\n    return props.children;\n}\n",
    "utils/mergeCls.cl.jac": "import from \"clsx\" {clsx, ClassValue }\nimport from \"tailwind-merge\" { twMerge }\n\ndef: pub cn(input:any) -> str{\n   inputs = [].slice.call(arguments);\n   return twMerge(clsx(inputs));\n}",
    "semantics/semantics_old.jac": "\"\"\"This module defines all semantic objects, enums, and AI-powered functions used by Algo for natural language understanding and graph generation.\"\"\"\n\nimport from byllm.lib { Model }\n\nglob llm = Model(model_name=\"gpt-4.1\");\n\n\"\"\"Represents the emotional state detected from user's message\"\"\"\nobj EmotionalState {\n    has state: str;\n    has confidence: float;\n    has reasoning: str;\n}\n\nsem EmotionalState.state = \"User's current emotional state: stressed, excited, indecisive, fatigued, or neutral\";\nsem EmotionalState.confidence = \"Confidence score between 0.0 and 1.0\";\nsem EmotionalState.reasoning = \"Brief explanation of why this state was detected\";\n\n\"\"\"Detect the user's emotional state from their message and conversation context\"\"\"\ndef detect_emotional_state(\n    user_message: str,\n    conversation_history: list[dict[str, str]]\n) -> EmotionalState by llm();\n\nsem detect_emotional_state = \"\"\"\nDetect emotional state from message:\n- stressed: frustration, overwhelm\n- excited: enthusiasm, accomplishments  \n- indecisive: uncertainty, questions\n- fatigued: tired, exhausted\n- neutral: normal tone\n\nConfidence 0.0-1.0.\n\"\"\";\n\n\"\"\"Generate a natural, conversational response matching user's emotional state\"\"\"\ndef generate_friendly_response(\n    user_message: str,\n    emotional_state: EmotionalState,\n    action_taken: str,\n    task_names: list[str]\n) -> str by llm();\n\nsem generate_friendly_response = \"\"\"\nGenerate warm, natural response as Algo:\n\nMatch emotional_state tone (stressed\u2192supportive, excited\u2192enthusiastic, etc.)\nAcknowledge action naturally (\"Got it!\" not \"Task added\")\nBrief 1-3 sentences, use contractions, no tech jargon.\n\"\"\";\n\n\"\"\"Conversation intent classification\"\"\"\nenum ConversationIntent {\n    COMMIT_ACTION,\n    CORRECT_PREVIOUS,\n    CLARIFY_PREVIOUS,\n    ASK_QUESTION,\n    THINK_ALOUD\n}\n\n\"\"\"Represents what the user is referring to in conversation\"\"\"\nobj ConversationContext {\n    has intent: ConversationIntent;\n    has referring_to_task: str;\n    has correction_type: str;\n    has needs_graph_rebuild: bool;\n    has is_insertion: bool;\n    has tasks_to_move: list[str];\n}\n\nsem ConversationContext.intent = \"COMMIT_ACTION: new task commitment | CORRECT_PREVIOUS: 'actually', 'before', 'first' corrections | CLARIFY_PREVIOUS: 'no i meant', 'after X' clarifications | ASK_QUESTION: questions | THINK_ALOUD: wondering/maybe\";\nsem ConversationContext.referring_to_task = \"Which existing task is user referring to? Empty if none, or task name from existing_nodes\";\nsem ConversationContext.correction_type = \"For CORRECT_PREVIOUS: 'insert_before', 'reorder', 'replace' | For CLARIFY_PREVIOUS: 'attachment_point', 'sequence_order' | Empty otherwise\";\nsem ConversationContext.needs_graph_rebuild = \"TRUE for CORRECT_PREVIOUS or CLARIFY_PREVIOUS with existing tasks, FALSE for COMMIT_ACTION on empty/simple graphs\";\nsem ConversationContext.is_insertion = \"TRUE if user wants to insert task BETWEEN existing tasks (keywords: 'before X', 'after Y but before Z', 'between', 'insert'). Example: 'wash face before heading to gym' when both exist\";\nsem ConversationContext.tasks_to_move = \"List of existing task names that are being repositioned/reordered. Example: user says 'have coffee first' when HaveCoffee already exists \u2192 ['HaveCoffee']\";\n\n\"\"\"Intent and commitment analysis result\"\"\"\nobj IntentAnalysis {\n    has should_create_tasks: bool;\n    has conversation_context: ConversationContext;\n    has confidence: float;\n}\n\nsem IntentAnalysis.should_create_tasks = \"TRUE if user committed to action OR is correcting/reordering existing tasks. FALSE only for questions/thinking/uncertain. CRITICAL: Corrections and reorderings NEED graph updates, so should_create_tasks MUST be True\";\nsem IntentAnalysis.conversation_context = \"Context about what user is doing: correcting, clarifying, committing new\";\nsem IntentAnalysis.confidence = \"Confidence 0.0-1.0 in the intent classification\";\n\n\"\"\"Analyze conversation intent and determine if user is committing, correcting, or clarifying\"\"\"\ndef analyze_conversation_intent(\n    user_message: str,\n    conversation_history: list[dict[str, str]],\n    existing_nodes: list[str],\n    last_task: str\n) -> IntentAnalysis by llm();\n\nsem analyze_conversation_intent = \"\"\"\nAnalyze user's message and recent conversation history to classify their intent.\nPopulate IntentAnalysis with appropriate values based on semantic definitions.\n\nCRITICAL: should_create_tasks MUST BE TRUE FOR:\n1. New task commitments: \"I'll make coffee then check news\"\n2. Corrections: \"actually, have coffee before checking news\"\n3. Reorderings: \"take coffee first\", \"go to gym after washing face\"\n4. Insertions: \"wash face before heading to gym\"\n\nshould_create_tasks SHOULD BE FALSE ONLY FOR:\n- Pure questions: \"what should I do next?\"\n- Thinking aloud: \"maybe I should...\"\n- Uncertain statements: \"I might go to the gym\"\n\nREORDERING DETECTION:\nIf user mentions existing task with reordering keywords ('first', 'before that', 'earlier', 'after', 'then'):\n- Set should_create_tasks = True (CRITICAL!)\n- Set correction_type = 'reorder'\n- Set needs_graph_rebuild = True\n- Populate tasks_to_move with the task names being repositioned\nExample: \"have coffee first\" when HaveCoffee exists \u2192 tasks_to_move = [\"HaveCoffee\"], should_create_tasks = True\n\nDefault to COMMIT_ACTION when user mentions tasks/actions.\nCheck last 2-3 conversation turns for context.\n\"\"\";\n\n\"\"\"Maps raw task name to unique task name with count\"\"\"\nobj TaskNameMapping {\n    has raw: str;\n    has unique: str;\n    has count: int;\n}\n\nsem TaskNameMapping.raw = \"Base task name extracted from message\";\nsem TaskNameMapping.unique = \"Unique task name with number appended if duplicate\";\nsem TaskNameMapping.count = \"How many times this raw name appeared in existing_nodes\";\n\n\"\"\"Extracted task names from user message\"\"\"\nobj ExtractedTasks {\n    has raw_names: list[str];\n    has unique_names: list[str];\n    has name_mappings: list[TaskNameMapping];\n    has duplicate_counts: list[int];\n}\n\nsem ExtractedTasks.raw_names = \"Base task names in CamelCase extracted from message (e.g., CheckEmail, MakeCoffee)\";\nsem ExtractedTasks.unique_names = \"NEW unique task names to create. CORRECTION/INSERTION LOGIC: If correction_type='insert_before' OR is_insertion=True OR user says 'before', 'after', 'instead', 'actually', then use existing task names WITHOUT numbers (reusing existing tasks). Otherwise, append numbers for duplicates. Formula: if needs_reuse then use raw_name as-is, else if count>0 then raw_name+str(count+1) else raw_name\";\nsem ExtractedTasks.name_mappings = \"List of {raw: str, unique: str, count: int} showing transformation for each task\";\nsem ExtractedTasks.duplicate_counts = \"For each raw_name, how many times it appears in existing_nodes. Used to calculate unique_names\";\n\n\"\"\"Extract raw task names from user message in CamelCase format\"\"\"\ndef extract_raw_task_names(\n    user_message: str,\n    conversation_context: ConversationContext,\n    existing_nodes: list[str]\n) -> ExtractedTasks by llm();\n\nsem extract_raw_task_names = \"\"\"\nExtract task names and generate unique names.\n\nCRITICAL: ALWAYS EXTRACT TASK NAMES even when they already exist in the graph!\n\nREORDERING MODE (correction_type='reorder' OR tasks_to_move is populated):\n- Extract the task names being reordered from user_message\n- Use EXISTING names without adding numbers\n- Example: User says \"have coffee before checking news\" when TakeCoffee and CheckNews exist\n  \u2192 raw_names = [\"TakeCoffee\", \"CheckNews\"]\n  \u2192 unique_names = [\"TakeCoffee\", \"CheckNews\"] (no numbers added)\n\nCORRECTION/INSERTION MODE (conversation_context.is_insertion=True OR correction_type='insert_before' OR keywords like 'before', 'after', 'between', 'instead'):\n- If task exists in existing_nodes, use the EXISTING name without adding numbers\n- User is correcting/modifying existing flow, not creating new duplicate tasks\n- Example: User says \"wash face before heading to gym\", and both WashFace and HeadToGym exist \u2192 use WashFace and HeadToGym (not WashFace2, HeadToGym2)\n\nNORMAL MODE:\n- Append numbers for duplicate task names when creating truly new occurrences\n- Formula: if count>0 then raw_name+str(count+1) else raw_name\n\nPopulate all fields including duplicate_counts.\n\"\"\";\n\n\"\"\"Determine where new tasks should attach in the graph\"\"\"\nobj AttachmentPointAnalysis {\n    has attachment_nodes: list[str];\n    has is_convergent: bool;\n    has reasoning: str;\n    has user_specified: bool;\n}\n\nsem AttachmentPointAnalysis.attachment_nodes = \"List of node(s) to attach from. Usually [last_task] or multiple for convergence\";\nsem AttachmentPointAnalysis.is_convergent = \"TRUE if attaching from multiple nodes (convergent edge)\";\nsem AttachmentPointAnalysis.reasoning = \"Explanation of why these attachment points were chosen\";\nsem AttachmentPointAnalysis.user_specified = \"TRUE if user explicitly named a task (e.g., 'after X'), FALSE if using default last_task\";\n\n\"\"\"Determine where new tasks should attach in the graph\"\"\"\ndef determine_attachment_points(\n    user_message: str,\n    last_task: str,\n    existing_nodes: list[str],\n    conversation_context: ConversationContext\n) -> AttachmentPointAnalysis by llm();\n\nsem determine_attachment_points = \"\"\"\nAnalyze where new tasks should connect in the graph.\n\nINSERTION PATTERN (user says \"BEFORE X\"):\nExample: \"wash face before heading to gym\" when graph has CheckMessages->HeadToGym\n- Find the task BEFORE the referenced task in existing graph\n- attachment_nodes = [task that currently connects TO the referenced task]\n- Example result: attachment_nodes = [\"CheckMessages\"] (the task before HeadToGym)\n- This allows creating: CheckMessages->WashFace->HeadToGym\n\nIf conversation_context.needs_graph_rebuild = True:\n   - Return empty attachment_nodes (will rebuild full graph)\n   - reasoning explains the correction/clarification\n\nOtherwise:\n- Default: attachment_nodes = [last_task]\n- User-specified: Parse user_message for \"after X\", \"before Y\", \"from Z\"\n\nAlways provide clear reasoning for transparency.\n\"\"\";\n\n\"\"\"Detection of convergence patterns in user intent\"\"\"\nobj ConvergenceIntent {\n    has should_converge: bool;\n    has source_nodes: list[str];\n    has convergence_type: str;\n    has trigger_phrase: str;\n}\n\nsem ConvergenceIntent.should_converge = \"TRUE if user intends parallel branches to merge\";\nsem ConvergenceIntent.source_nodes = \"List of nodes to converge from (leaf nodes)\";\nsem ConvergenceIntent.convergence_type = \"explicit (keywords like 'either way') | implicit (last_task has '|' and no specific task named) | none (no convergence)\";\nsem ConvergenceIntent.trigger_phrase = \"The phrase that triggered convergence detection\";\n\n\"\"\"Detect if user intends to converge parallel branches\"\"\"\ndef detect_convergence_intent(\n    user_message: str,\n    last_task: str,\n    current_edges: list[dict[str, str]]\n) -> ConvergenceIntent by llm();\n\nsem detect_convergence_intent = \"\"\"\nDetect convergence patterns from user message.\n\nTypes:\n1. EXPLICIT convergence (should_converge=True):\n   - Keywords: \"either way\", \"regardless\", \"in both cases\", \"afterwards\" (after branches)\n\n2. IMPLICIT convergence (should_converge=True):\n   - last_task contains \"|\" (e.g., \"GoToGym|GoForRun\")\n   - User adds task WITHOUT naming specific source\n\n3. NO convergence (should_converge=False):\n   - User names specific task: \"after GoToGym\"\n   - Linear flow: normal \"then X\" when last_task is single\n\nExtract source_nodes by splitting last_task by \"|\" if convergence detected.\n\"\"\";\n\n\"\"\"Represents a task connection type in the graph\"\"\"\nenum ConnectionType {\n    SEQUENTIAL,\n    PARALLEL,\n    CONDITIONAL,\n    CONVERGENT\n}\n\n\"\"\"Task relationship with clear sequencing\"\"\"\nobj TaskRelationship {\n    has connection_type: ConnectionType;\n    has from_task: str;\n    has to_task: str;\n    has edge_label: str;\n    has sequence_order: int;\n}\n\nsem TaskRelationship.connection_type = \"SEQUENTIAL: then/after | PARALLEL: and/also/while/same time | CONDITIONAL: if/otherwise | CONVERGENT: merge point\";\nsem TaskRelationship.from_task = \"Task name in CamelCase (previous task in sequence)\";\nsem TaskRelationship.to_task = \"Next task name in CamelCase (e.g., MakeCoffee, BrushTeeth)\";\nsem TaskRelationship.edge_label = \"Edge label: 'then', 'if raining', 'otherwise', etc.\";\nsem TaskRelationship.sequence_order = \"Sequence number (1, 2, 3...) to preserve order when multiple relationships\";\n\n\"\"\"Build task relationships using pre-analyzed context\"\"\"\ndef build_task_relationships(\n    user_message: str,\n    extracted_tasks: ExtractedTasks,\n    attachment_analysis: AttachmentPointAnalysis,\n    convergence_intent: ConvergenceIntent,\n    conversation_context: ConversationContext,\n    current_edges: list[dict[str, str]]\n) -> list[TaskRelationship] by llm();\n\nsem build_task_relationships = \"\"\"\nBuild TaskRelationship list using pre-analyzed inputs.\n\nCRITICAL: RETURN PROPER JSON STRUCTURE\nEach TaskRelationship object MUST have separate fields:\n{\n  \"connection_type\": \"SEQUENTIAL\",\n  \"from_task\": \"CheckMessages\",\n  \"to_task\": \"WashFace\",\n  \"edge_label\": \"then\",\n  \"sequence_order\": 1\n}\n\nNEVER concatenate fields like: from_task='WashFace to_task=HeadToGym label=then'\n\nCRITICAL: USE ACTUAL TASK NAMES\n- from_task MUST be an actual task name (e.g., \"Start\", \"BrushTeeth\", \"WakeUp\")\n- to_task MUST be an actual task name from extracted_tasks.unique_names\n- attachment_analysis.attachment_nodes contains the ACTUAL task names to attach from\n- NEVER use placeholder text like \"last_task\" - use the actual task name from attachment_nodes\n\nREORDERING TASKS (correction_type='reorder', tasks_to_move is populated):\nWhen user wants to reposition an existing task:\n\nExample scenario:\n- User: \"have coffee first, then check the news\"\n- Current graph: CheckNews -> BrushTeeth -> HaveCoffee -> WashFace\n- tasks_to_move: [\"HaveCoffee\"]\n- current_edges: [\n    {from: \"CheckNews\", to: \"BrushTeeth\", label: \"then\"},\n    {from: \"BrushTeeth\", to: \"HaveCoffee\", label: \"then\"},\n    {from: \"HaveCoffee\", to: \"WashFace\", label: \"then\"}\n  ]\n\nSTEP 1: Identify what to remove\n- Find ALL edges involving HaveCoffee:\n  - Incoming: BrushTeeth -> HaveCoffee (remove)\n  - Outgoing: HaveCoffee -> WashFace (remove)\n\nSTEP 2: Fill the gap\n- The task BEFORE HaveCoffee was BrushTeeth\n- The task AFTER HaveCoffee was WashFace\n- Create new edge: BrushTeeth -> WashFace\n\nSTEP 3: Create new position\n- User wants: HaveCoffee -> CheckNews\n- The task BEFORE CheckNews was nothing (Start implied)\n- Create edges:\n  - Start -> HaveCoffee (or from attachment point)\n  - HaveCoffee -> CheckNews\n\nRETURN ALL relationships to create the complete new graph:\n1. {from_task: \"Start\", to_task: \"HaveCoffee\", edge_label: \"then\", sequence_order: 1}\n2. {from_task: \"HaveCoffee\", to_task: \"CheckNews\", edge_label: \"then\", sequence_order: 2}\n3. {from_task: \"CheckNews\", to_task: \"BrushTeeth\", edge_label: \"then\", sequence_order: 3}\n4. {from_task: \"BrushTeeth\", to_task: \"WashFace\", edge_label: \"then\", sequence_order: 4}\n\nThe rebuild process will remove all old edges and create only these new ones.\n\nINSERTION DETECTION (using current_edges):\nIf user says \"wash face BEFORE heading to gym\":\n1. Check current_edges for edge ending at HeadToGym (e.g., CheckMessages->HeadToGym)\n2. Find the from_task of that edge (CheckMessages)\n3. Create relationships to INSERT WashFace:\n   - CheckMessages -> WashFace (label: \"then\")\n   - WashFace -> HeadToGym (label: \"then\")\n4. needs_graph_rebuild should be True to remove the old CheckMessages->HeadToGym edge\n\nCONNECTION RULES:\n- Start point: Use attachment_nodes[0] as the from_task for the FIRST relationship\n- For extracted_tasks.unique_names: [\"BrushTeeth\", \"MakeCoffee\", \"GoToGym\"]\n- For attachment_nodes: [\"Start\"]\n- Create: Start -> BrushTeeth, BrushTeeth -> MakeCoffee, MakeCoffee -> GoToGym\n\nCRITICAL CONNECTION TYPE DETECTION:\nAnalyze user_message for parallel keywords:\n- PARALLEL: \"while\", \"as\", \"during\", \"at the same time\", \"simultaneously\", \"and\" (when tasks happen together)\n    - Create N relationships, ALL with SAME from_task (attachment_nodes[0])\n    - ALL relationships use connection_type = PARALLEL\n    - Each relationship goes to a different unique task\n    - sequence_order: 1, 2, 3... for each parallel branch\n  \n- SEQUENTIAL: \"then\", \"after\", \"next\", \"before\", \"first\" (tasks happen one after another)\n    - Create N relationships chained together\n    - First: from attachment_nodes[0] to unique_names[0]\n    - Second: from unique_names[0] to unique_names[1]\n    - Continue chaining: each new task's from_task is the previous to_task\n\nIf needs_graph_rebuild=True: Reconstruct FULL graph with ALL existing nodes\nIf convergence_intent.should_converge: Create edges from ALL source_nodes to first unique task\n\"\"\";\n\n\"\"\"Generate 2 contextual suggestions for what the user might do next\"\"\"\ndef generate_next_suggestions(\n    last_task: str,\n    recent_tasks: list[str],\n    conversation_context: ConversationContext,\n    emotional_state: EmotionalState\n) -> list[str] by llm();\n\nsem generate_next_suggestions = \"\"\"\nGenerate exactly 2 short, natural suggestions (3-5 words each) for what the user might do next.\n\nGuidelines:\n- Keep them conversational and first-person (\"I'll make coffee\" not \"Make coffee\")\n- Base them on typical routine patterns and the current context\n- Consider time of day and flow (morning \u2192 breakfast, lunch \u2192 afternoon tasks)\n- Make them diverse (different types of activities)\n- Keep them brief and actionable\n\nExamples:\nAfter \"WakeUp\" \u2192 [\"I'll make coffee\", \"I'll take a shower\"]\nAfter \"HaveLunch\" \u2192 [\"I'll get back to work\", \"I'll take a short break\"]\nAfter \"FinishWork\" \u2192 [\"I'll head home\", \"I'll grab dinner\"]\nAfter \"Dinner\" \u2192 [\"I'll watch TV\", \"I'll read a book\"]\n\nReturn as a simple list of 2 strings, nothing else.\n\"\"\";\n\n\"\"\"Thinking insights to show user (transparency feature)\"\"\"\nobj ThinkingSummary {\n    has emotional_insight: str;\n    has intent_insight: str;\n    has task_insight: str;\n    has pattern_insight: str;\n}\n\nsem ThinkingSummary.emotional_insight = \"Short bullet about user's emotional state. Empty string if confidence < 0.7. Format: 'You seem [state] right now'\";\nsem ThinkingSummary.intent_insight = \"Short bullet about what user is doing. Empty string for simple COMMIT_ACTION. Format: 'You're [correcting/clarifying/asking about] [context]'\";\nsem ThinkingSummary.task_insight = \"Short bullet about tasks extracted. Use friendly names not CamelCase. Format: 'I'm extracting: [list of tasks]' or 'I'm adding: [task description]'\";\nsem ThinkingSummary.pattern_insight = \"Short bullet about special patterns. Empty if none. Format: 'These will happen [at the same time/one after another/either way]' or 'This is task number [X]' for duplicates\";\n\n\"\"\"Generate user-friendly thinking insights for transparency\"\"\"\ndef generate_thinking_summary(\n    user_message: str,\n    emotional_state: EmotionalState,\n    intent_analysis: IntentAnalysis,\n    extracted_tasks: ExtractedTasks,\n    attachment_analysis: AttachmentPointAnalysis,\n    convergence_intent: ConvergenceIntent\n) -> ThinkingSummary by llm();\n\nsem generate_thinking_summary = \"\"\"\nGenerate short, friendly bullet points showing Algo's understanding.\n\nRULES:\n1. emotional_insight: Be empathetic and natural\n\n2. intent_insight: Format - \"You're correcting [task]\" or \"You're clarifying where [task] goes\"\n\n3. task_insight: For duplicates, mention the count naturally\n\n4. pattern_insight: Only for special patterns, otherwise empty string\n   - PARALLEL: \"These will happen at the same time\"\n   - Duplicates (check extracted_tasks.duplicate_counts): \"This is your [X]th time doing this\"\n\nKeep all bullets under 10 words. Be conversational and natural.\n\"\"\";\n",
    "semantics/semantics.jac": "\"\"\"This module defines all semantic objects, enums, and AI-powered functions used by Algo for natural language understanding and graph generation.\"\"\"\n\nimport from byllm.lib { Model }\n\nglob llm = Model(model_name=\"gpt-4.1\");\n\n\"\"\"Represents the emotional state detected from user's message\"\"\"\nobj EmotionalState {\n    has state: str;\n    has confidence: float;\n    has reasoning: str;\n}\n\n\"\"\"Detect the user's emotional state from their message and conversation context\"\"\"\ndef detect_emotional_state(\n    user_message: str,\n    conversation_history: list[dict[str, str]]\n) -> EmotionalState by llm();\n\nsem detect_emotional_state = \"\"\"\nDetect emotional state: stressed | excited | indecisive | fatigued | neutral\n\nstate = \"Current emotional state\";\nconfidence = \"Score 0.0-1.0\";\nreasoning = \"Brief detection rationale\";\n\"\"\";\n\n\"\"\"Generate a natural, conversational response matching user's emotional state\"\"\"\ndef generate_friendly_response(\n    user_message: str,\n    emotional_state: EmotionalState,\n    action_taken: str,\n    task_names: list[str]\n) -> str by llm();\n\nsem generate_friendly_response = \"\"\"\nGenerate warm response matching emotional_state tone.\nNatural acknowledgment (\"Got it!\" not \"Task added\"), 1-3 sentences, contractions, no jargon.\n\"\"\";\n\n\"\"\"Conversation intent classification\"\"\"\nenum ConversationIntent {\n    COMMIT_ACTION,\n    CORRECT_PREVIOUS,\n    CLARIFY_PREVIOUS,\n    ASK_QUESTION,\n    THINK_ALOUD\n}\n\n\"\"\"Represents what the user is referring to in conversation\"\"\"\nobj ConversationContext {\n    has intent: ConversationIntent;\n    has referring_to_task: str;\n    has correction_type: str;\n    has needs_graph_rebuild: bool;\n    has is_insertion: bool;\n    has tasks_to_move: list[str];\n}\n\n\"\"\"Intent and commitment analysis result\"\"\"\nobj IntentAnalysis {\n    has should_create_tasks: bool;\n    has conversation_context: ConversationContext;\n    has confidence: float;\n}\n\n\"\"\"Analyze conversation intent and determine if user is committing, correcting, or clarifying\"\"\"\ndef analyze_conversation_intent(\n    user_message: str,\n    conversation_history: list[dict[str, str]],\n    existing_nodes: list[str],\n    last_task: str\n) -> IntentAnalysis by llm();\n\nsem analyze_conversation_intent = \"\"\"\nClassify user intent from message and conversation history.\n\nshould_create_tasks = \"TRUE if user mentions ANY action/task (even casual ones like 'check messages', 'grab lunch', 'take a walk'). \nOnly FALSE for explicit questions ('what should I do?', 'can you help?') or pure uncertainty ('maybe', 'not sure', 'wondering')\";\n\nConversationContext.intent = \"COMMIT_ACTION: ANY action mentioned (default unless clearly asking/uncertain) | CORRECT_PREVIOUS: 'actually', 'before', 'first' | CLARIFY_PREVIOUS: 'no i meant', 'after X' | ASK_QUESTION: explicit questions | THINK_ALOUD: 'maybe', 'wondering', 'not sure'\";\n\nConversationContext.referring_to_task = \"EXACT task name from existing_nodes user is referencing. Examples: 'rename X to Y'\u2192'X', 'before Y'\u2192'Y', 'watch movie' matching 'WatchSomeNetflix'\u2192'WatchSomeNetflix'. Empty if none\";\n\nConversationContext.correction_type = \"CORRECT_PREVIOUS types:\n- rename: Change task NAME only (same activity, different label) - 'actually call it X'\n- insert_before/insert_after/insert_first: NEW task between/before existing\n- reorder: Move EXISTING task to different position\n- replace: Swap with COMPLETELY DIFFERENT task\nCLARIFY_PREVIOUS: 'attachment_point' | 'sequence_order' | Empty otherwise\";\n\nConversationContext.needs_graph_rebuild = \"TRUE for corrections/clarifications with existing tasks, FALSE for simple additions\";\nConversationContext.is_insertion = \"TRUE if inserting task BETWEEN existing tasks\";\nConversationContext.tasks_to_move = \"List of existing task names being repositioned (e.g., ['HaveCoffee'])\";\n\nconfidence = \"Score 0.0-1.0\";\n\"\"\";\n\n\"\"\"Maps raw task name to unique task name with count\"\"\"\nobj TaskNameMapping {\n    has raw: str;\n    has unique: str;\n    has count: int;\n}\n\n\"\"\"Extracted task names from user message\"\"\"\nobj ExtractedTasks {\n    has raw_names: list[str];\n    has unique_names: list[str];\n    has name_mappings: list[TaskNameMapping];\n    has duplicate_counts: list[int];\n    has renamed_to: str;  # For rename operations: the new task name ONLY\n}\n\n\"\"\"Extract raw task names from user message in CamelCase format\"\"\"\ndef extract_raw_task_names(\n    user_message: str,\n    conversation_context: ConversationContext,\n    existing_nodes: list[str]\n) -> ExtractedTasks by llm();\n\nsem extract_raw_task_names = \"\"\"\nExtract task names and generate unique names.\n\nCRITICAL: ALWAYS EXTRACT TASK NAMES even when they already exist in the graph!\n\nRENAME MODE (correction_type='rename'):\n- Populate the 'renamed_to' field with the NEW task name (the one being renamed TO)\n- DO NOT populate raw_names or unique_names with the old task name\n- Set renamed_to to the task name that comes AFTER \"to\" or \"instead\"\n- Examples:\n  * \"rename IfItIsRainingIWillReadMyBook to ReadBook\" \u2192 renamed_to = \"ReadBook\", raw_names = [], unique_names = []\n  * \"rename that task, have chat with colleagues, to chat with colleagues instead\" \u2192 renamed_to = \"ChatWithColleagues\"\n  * \"rename the task Continue working on project to Project Work\" \u2192 renamed_to = \"ProjectWork\"\n  * \"rename ContinueWorkingOnProject to ProjectWork\" \u2192 renamed_to = \"ProjectWork\"\n\nREORDERING MODE (correction_type='reorder' OR tasks_to_move is populated):\n- Extract the task names being reordered from user_message\n- Use EXISTING names without adding numbers\n- Example: User says \"have coffee before checking news\" when TakeCoffee and CheckNews exist\n  \u2192 raw_names = [\"TakeCoffee\", \"CheckNews\"]\n  \u2192 unique_names = [\"TakeCoffee\", \"CheckNews\"] (no numbers added)\n\nCORRECTION/INSERTION MODE (conversation_context.is_insertion=True OR correction_type='insert_before' OR keywords like 'before', 'after', 'between', 'instead'):\n- If task exists in existing_nodes, use the EXISTING name without adding numbers\n- User is correcting/modifying existing flow, not creating new duplicate tasks\n- Example: User says \"wash face before heading to gym\", and both WashFace and HeadToGym exist \u2192 use WashFace and HeadToGym (not WashFace2, HeadToGym2)\n\nNORMAL MODE:\n- Append numbers for duplicate task names when creating truly new occurrences\n- Formula: if count>0 then raw_name+str(count+1) else raw_name (Example: \"MakeCoffee\" exists \u2192 new unique name \"MakeCoffee2\")\n\nPopulate all fields including duplicate_counts.\n\"\"\";\n\n\"\"\"Determine where new tasks should attach in the graph\"\"\"\nobj AttachmentPointAnalysis {\n    has attachment_nodes: list[str];\n    has is_convergent: bool;\n    has reasoning: str;\n    has user_specified: bool;\n}\n\n\"\"\"Determine where new tasks should attach in the graph\"\"\"\ndef determine_attachment_points(\n    user_message: str,\n    last_task: str,\n    existing_nodes: list[str],\n    conversation_context: ConversationContext\n) -> AttachmentPointAnalysis by llm();\n\nsem determine_attachment_points = \"\"\"\nDetermine where new tasks connect.\n\nattachment_nodes = \"Node(s) to attach from: [last_task] default, multiple for convergence, or task BEFORE referenced for 'before X' patterns\";\nis_convergent = \"TRUE if multiple attachment nodes\";\nreasoning = \"Brief explanation\";\nuser_specified = \"TRUE if user named specific task ('after X')\";\n\nIf needs_graph_rebuild=True: return empty attachment_nodes.\nFor 'before X': find predecessor of X in current edges.\nDefault: [last_task] unless user specifies 'after X', 'before Y', 'from Z'.\n\"\"\";\n\n\"\"\"Detection of convergence patterns in user intent\"\"\"\nobj ConvergenceIntent {\n    has should_converge: bool;\n    has source_nodes: list[str];\n    has convergence_type: str;\n    has trigger_phrase: str;\n}\n\n\"\"\"Detect if user intends to converge parallel branches\"\"\"\ndef detect_convergence_intent(\n    user_message: str,\n    last_task: str,\n    current_edges: list[dict[str, str]]\n) -> ConvergenceIntent by llm();\n\nsem detect_convergence_intent = \"\"\"\nDetect if parallel branches should merge.\n\nshould_converge = \"TRUE if merging branches\";\nsource_nodes = \"Leaf nodes to converge from (split last_task by '|')\";\nconvergence_type = \"explicit ('either way') | implicit (last_task has '|') | none\";\ntrigger_phrase = \"Detection trigger phrase\";\n\"\"\";\n\n\"\"\"Represents a task connection type in the graph\"\"\"\nenum ConnectionType {\n    SEQUENTIAL,\n    PARALLEL,\n    CONDITIONAL,\n    CONVERGENT\n}\n\n\"\"\"Task relationship with clear sequencing\"\"\"\nobj TaskRelationship {\n    has connection_type: ConnectionType;\n    has from_task: str;\n    has to_task: str;\n    has edge_label: str;\n    has sequence_order: int;\n}\n\n\"\"\"Build task relationships using pre-analyzed context\"\"\"\ndef build_task_relationships(\n    user_message: str,\n    extracted_tasks: ExtractedTasks,\n    attachment_analysis: AttachmentPointAnalysis,\n    convergence_intent: ConvergenceIntent,\n    conversation_context: ConversationContext,\n    current_edges: list[dict[str, str]]\n) -> list[TaskRelationship] by llm();\n\nsem build_task_relationships = \"\"\"\nBuild TaskRelationship list using pre-analyzed inputs.\n\nCRITICAL: DEFAULT BEHAVIOR - INCREMENTAL ADDITION\nFor normal COMMIT_ACTION with conversation_context.needs_graph_rebuild=False:\n- Return ONLY the NEW relationships being added\n- Do NOT include existing relationships from current_edges\n\nFULL REBUILD MODE (conversation_context.needs_graph_rebuild=True):\nWhen user is correcting/reordering existing tasks:\n- Return ALL relationships to reconstruct the complete graph INCLUDING ALL EXISTING EDGES from current_edges\n- CRITICAL: Start by INCLUDING all relationships from current_edges, then modify only the affected area\n- For INSERTION corrections (insert_before, insert_after, insert_first):\n  * Include ALL existing edges from current_edges\n  * Remove only the edge being split (e.g., if inserting between A->C, remove A->C)\n  * Add the new insertion edges (A->NewTask, NewTask->C)\n  * CRITICAL: Reconnect downstream tasks - if inserting B between A and C, return: A->B, B->C\n  * Example: Graph is Start->CheckMessages->MakeBreakfast->GoToGym, user says \"wash face after breakfast\"\n    Return ALL edges: Start->CheckMessages, CheckMessages->MakeBreakfast, MakeBreakfast->WashFace, WashFace->GoToGym\n- For REORDER corrections: rebuild with tasks in new positions\n\nCRITICAL: RETURN PROPER JSON STRUCTURE\nEach TaskRelationship object MUST have separate fields:\n{\n  \"connection_type\": \"SEQUENTIAL\",\n  \"from_task\": \"CheckMessages\",\n  \"to_task\": \"WashFace\",\n  \"edge_label\": \"then\",\n  \"sequence_order\": 1\n}\n\nconnection_type = \"SEQUENTIAL: then/after | PARALLEL: and/also/while/same time | CONDITIONAL: if/otherwise |\nCONVERGENT: merge point\";\nfrom_task = \"Task name in CamelCase (previous task in sequence)\";\nto_task = \"Next task name in CamelCase (e.g., MakeCoffee, BrushTeeth)\";\nedge_label = \"Edge label: 'then', 'if raining', 'otherwise', 'while', 'at the same time', etc.\";\nsequence_order = \"Sequence number (1, 2, 3...) to preserve order when multiple relationships\";\n\nNEVER concatenate fields like: from_task='WashFace to_task=HeadToGym label=then'\n\nCONNECTION RULES:\n- Start point: Use attachment_nodes[0] as the from_task for the FIRST relationship\n- For extracted_tasks.unique_names: [\"BrushTeeth\", \"MakeCoffee\", \"GoToGym\"]\n- For attachment_nodes: [\"Start\"]\n- Create: Start -> BrushTeeth, BrushTeeth -> MakeCoffee, MakeCoffee -> GoToGym\n\nCRITICAL EDGE LABEL RULES:\n- \"then\" or \"afterwards\": Default for sequential tasks (A happens, then B happens)\n- \"while\" or \"at same time\": For PARALLEL tasks (A and B happen simultaneously)\n- \"if X\" or \"otherwise\": For CONDITIONAL branches (if X happens do A, otherwise do B)\n- \"either way\": ONLY for CONDITIONAL convergence where if/otherwise branches merge (NOT for parallel tasks)\n- After PARALLEL tasks converge, use \"then\" or \"afterwards\" for the next sequential task\n- Example: \"have drink while chatting with buddies, then head home, then call a cab\"\n  \u2192 HaveDrink[label=\"while\"], ChatWithBuddies[label=\"while\"] from HeadToThePub\n  \u2192 HaveDrink->HeadHome[label=\"then\"], ChatWithBuddies->HeadHome[label=\"then\"]\n  \u2192 HeadHome->CallACab[label=\"then\"]\n- Example conditional: \"if raining, read book; otherwise, walk; either way go home\"\n  \u2192 IfRaining->ReadBook[label=\"if raining\"], Otherwise->Walk[label=\"otherwise\"]\n  \u2192 ReadBook->GoHome[label=\"either way\"], Walk->GoHome[label=\"either way\"]\n\nCRITICAL CONNECTION TYPE DETECTION:\nAnalyze user_message for parallel keywords:\n- PARALLEL: \"while\", \"as\", \"during\", \"at the same time\", \"simultaneously\", \"and\" (when tasks happen together)\n    - Create N relationships, ALL with SAME from_task (attachment_nodes[0])\n    - ALL relationships use connection_type = PARALLEL\n    - Each relationship goes to a different unique task\n    - sequence_order: 1, 2, 3... for each parallel branch\n\nCRITICAL: CONVERGENCE HANDLING\nPARALLEL CONVERGENCE (multiple nodes converging after doing things simultaneously):\n- attachment_nodes contains multiple nodes from parallel activities\n- Create edges from EACH attachment node to the FIRST extracted task\n- Use \"then\" or \"afterwards\" for these converging edges (parallel tasks finished, now do next thing)\n- Example: attachment_nodes=[\"HaveADrink\", \"ChatWithBuddies\"], extracted_tasks=[\"HeadHome\", \"CallACab\"]\n  Result: HaveADrink->HeadHome[label=\"then\"], ChatWithBuddies->HeadHome[label=\"then\"], HeadHome->CallACab[label=\"then\"]\n\nCONDITIONAL CONVERGENCE (if/otherwise branches merging):\n- Only use \"either way\" label when converging CONDITIONAL branches (if X / otherwise)\n- The user must say \"either way\", \"both paths\", \"regardless\", or similar for conditional convergence\n- Example: \"if raining read book otherwise walk either way go home\"\n  \u2192 IfRaining->ReadBook, Otherwise->Walk, ReadBook->GoHome[label=\"either way\"], Walk->GoHome[label=\"either way\"]\n\"\"\";\n\n\"\"\"Generate 2 contextual suggestions for what the user might do next\"\"\"\ndef generate_next_suggestions(\n    last_task: str,\n    recent_tasks: list[str],\n    conversation_context: ConversationContext,\n    emotional_state: EmotionalState\n) -> list[str] by llm();\n\nsem generate_next_suggestions = \"\"\"\nGenerate exactly 2 short, natural suggestions (3-5 words each) for what the user might do next.\n\nGuidelines:\n- Keep them conversational and first-person (\"I'll make coffee\" not \"Make coffee\")\n- Base them on typical routine patterns and the current context\n- Consider time of day and flow (morning \u2192 breakfast, lunch \u2192 afternoon tasks)\n- Make them diverse (different types of activities)\n- Keep them brief and actionable\n\nExamples:\nAfter \"WakeUp\" \u2192 [\"I'll make coffee\", \"I'll take a shower\"]\nAfter \"HaveLunch\" \u2192 [\"I'll get back to work\", \"I'll take a short break\"]\nAfter \"FinishWork\" \u2192 [\"I'll head home\", \"I'll grab dinner\"]\nAfter \"Dinner\" \u2192 [\"I'll watch TV\", \"I'll read a book\"]\n\nReturn as a simple list of 2 strings, nothing else.\n\"\"\";\n\n\"\"\"Thinking insights to show user (transparency feature)\"\"\"\nobj ThinkingSummary {\n    has emotional_insight: str;\n    has intent_insight: str;\n    has task_insight: str;\n    has pattern_insight: str;\n}\n\n\"\"\"Generate user-friendly thinking insights for transparency\"\"\"\ndef generate_thinking_summary(\n    user_message: str,\n    emotional_state: EmotionalState,\n    intent_analysis: IntentAnalysis,\n    extracted_tasks: ExtractedTasks,\n    attachment_analysis: AttachmentPointAnalysis,\n    convergence_intent: ConvergenceIntent\n) -> ThinkingSummary by llm();\n\nsem generate_thinking_summary = \"\"\"\nGenerate short, friendly bullet points showing Algo's understanding.\n\nemotional_insight = \"Short bullet about user's emotional state. Empty string if confidence < 0.7. \nFormat: 'You seem [state] right now'\";\nintent_insight = \"Short bullet about what user is doing. Empty string for simple COMMIT_ACTION. \nFormat: 'You're [correcting/clarifying/asking about] [context]'\";\ntask_insight = \"Short bullet about tasks extracted. Show the ACTUAL extracted task names from extracted_tasks.unique_names. \nFormat: 'Extracted: [TaskName1], [TaskName2]' for parallel tasks OR 'Adding: [TaskName]' for single task\nExample: 'Extracted: TalkToFriend, WalkDog' OR 'Adding: MakeCoffee'\nIf multiple tasks with parallel pattern: 'Extracted: [Task1], [Task2] (parallel)'\";\npattern_insight = \"Short bullet about special patterns. Empty if none. \nFormat: 'These will happen [at the same time/one after another/either way]' or 'This is task number [X]' for duplicates\nFor parallel tasks detected: 'These happen at the same time' or 'These happen while doing each other'\";\n\nKeep all bullets under 10 words. Be conversational and natural.\n\"\"\";\n\n\"\"\"Task validation result\"\"\"\nobj TaskValidationResult {\n    has is_valid: bool;\n    has reason: str;\n    has missing_tasks: list[str];\n    has incorrect_task: str;      # Existing task with wrong name that should be renamed\n    has correct_task_name: str;    # What the task should be renamed to\n}\n\n\"\"\"Validate that extracted tasks match the user's message\"\"\"\ndef validate_task_extraction(\n    user_message: str,\n    extracted_tasks: list[str],\n    existing_nodes: list[str]\n) -> TaskValidationResult by llm();\n\nsem validate_task_extraction = \"\"\"\nValidate if the extracted tasks correctly capture ALL actions/activities mentioned in the user's message.\n\nCRITICAL: Look for:\n1. Conditional statements: \"if X, then Y; otherwise Z\" \u2192 BOTH tasks should be extracted\n2. Multiple activities in one message: \"I'll do X and then Y\" \u2192 BOTH tasks should be extracted\n3. Parallel tasks: \"while X, I'll also Y\" \u2192 BOTH tasks should be extracted\n4. Alternative scenarios: \"if I have time I'll X, otherwise I'll Y\" \u2192 BOTH tasks should be extracted\n5. TASK NAME CORRECTION: If extracted task is similar to an existing task but missing a verb or has wrong wording, signal a RENAME\n\nTASK NAME CORRECTION (rename needed):\n- Compare extracted_tasks with existing_nodes\n- If an extracted task is SEMANTICALLY THE SAME as an existing task but has a better/complete name:\n  * Set is_valid = false\n  * Set incorrect_task = the existing task with wrong/incomplete name\n  * Set correct_task_name = the better extracted task name\n  * Set reason = explanation of why rename is needed\n  * Set missing_tasks = [] (empty - no new task needed, just rename)\n- Examples of rename needed:\n  * existing_nodes: [\"TheGoodPlace\"], extracted: [\"WatchTheGoodPlace\"]\n    \u2192 incorrect_task=\"TheGoodPlace\", correct_task_name=\"WatchTheGoodPlace\", reason=\"TheGoodPlace should be renamed to WatchTheGoodPlace to include the verb 'Watch'\"\n  * existing_nodes: [\"Gym\"], extracted: [\"HeadToGym\"]\n    \u2192 incorrect_task=\"Gym\", correct_task_name=\"HeadToGym\", reason=\"Gym should be renamed to HeadToGym to include the action verb\"\n  * existing_nodes: [\"Messages\"], extracted: [\"CheckMessages\"]\n    \u2192 incorrect_task=\"Messages\", correct_task_name=\"CheckMessages\", reason=\"Messages should be renamed to CheckMessages to clarify the action\"\n\nExamples of INCORRECT extraction (missing tasks):\n- User: \"If I have assignments due I will work on them, if not I will netflix and chill\"\n  Extracted: [\"NetflixAndChill\"] \u2192 INVALID (missing \"WorkOnAssignments\")\n- User: \"I'll make coffee and then check my emails\"\n  Extracted: [\"MakeCoffee\"] \u2192 INVALID (missing \"CheckEmails\")\n- User: \"While brushing my teeth, I'll also check the news\"\n  Extracted: [\"BrushTeeth\"] \u2192 INVALID (missing \"CheckNews\")\n\nReturn:\n- is_valid: true if ALL tasks mentioned are captured correctly, false otherwise\n- reason: Brief explanation of what's wrong\n- missing_tasks: List of task names that were missed (empty if rename needed or if valid)\n- incorrect_task: Empty string if valid or if missing tasks; set to existing task name if rename needed\n- correct_task_name: Empty string if valid or if missing tasks; set to the correct name if rename needed\n\"\"\";\n\n\"\"\"Graph structure validation result\"\"\"\nobj GraphValidationResult {\n    has is_valid: bool;\n    has reason: str;\n    has expected_structure: str;\n}\n\n\"\"\"Validate that graph structure matches user's intent\"\"\"\ndef validate_graph_structure(\n    user_message: str,\n    graph_nodes: list[str],\n    graph_edges: list[dict[str, str]]\n) -> GraphValidationResult by llm();\n\nsem validate_graph_structure = \"\"\"\nValidate if the graph structure correctly represents the user's intent for NEWLY ADDED tasks.\n\nIMPORTANT CONTEXT:\n- graph_nodes: ONLY the newly added task names (not the entire graph)\n- graph_edges: ONLY edges involving the new tasks (as \"to\" destination)\n- The \"from\" task in edges is typically a pre-existing task - this is EXPECTED and VALID\n\nCheck for:\n1. Conditional branches: \"if X then Y, otherwise Z\" \u2192 New tasks should have proper conditional structure\n2. Sequential tasks: \"do X then Y\" \u2192 If user said \"do X then Y\", both should be added with X\u2192Y edge\n3. Parallel tasks: \"while X, also Y\" \u2192 Both tasks should branch from same source\n4. Convergence: \"either way\" \u2192 Tasks should merge into a common task\n\nExamples of CORRECT structure (pre-existing task \"ReadABook\" + new task \"MakeBreakfast\"):\n- User: \"make breakfast\"\n  graph_nodes: [\"MakeBreakfast\"]\n  graph_edges: [{\"from\": \"ReadABook\", \"to\": \"MakeBreakfast\", \"label\": \"then\"}]\n  \u2192 VALID: Single task added, connected from previous task\n\nExamples of INCORRECT structure:\n- User: \"I'll make coffee and then check emails\"\n  graph_nodes: [\"MakeCoffee\"]\n  graph_edges: [{\"from\": \"Start\", \"to\": \"MakeCoffee\", \"label\": \"then\"}]\n  \u2192 INVALID: Missing \"CheckEmails\" task mentioned in user message\n\n- User: \"if I have assignments I'll work on them, otherwise netflix\"\n  graph_nodes: [\"NetflixAndChill\"]\n  graph_edges: [{\"from\": \"Start\", \"to\": \"NetflixAndChill\", \"label\": \"then\"}]\n  \u2192 INVALID: Missing conditional branch \"WorkOnAssignments\"\n\nReturn:\n- is_valid: true if the new tasks are correctly connected\n- reason: Brief explanation of what's wrong (empty if valid)\n- expected_structure: Description of what SHOULD exist (empty if valid)\n\"\"\";\n\n#===========================================================\n#           OPERATION-SPECIFIC VALIDATION FUNCTIONS\n#===========================================================\n\n\"\"\"Rename validation result\"\"\"\nobj RenameValidationResult {\n    has is_valid: bool;\n    has reason: str;\n    has old_task_found: bool;\n    has new_task_unique: bool;\n    has edges_updated: bool;\n}\n\n\"\"\"Validate that a rename operation was executed correctly\"\"\"\ndef validate_rename_operation(\n    user_message: str,\n    old_task: str,\n    new_task: str,\n    before_nodes: list[str],\n    after_nodes: list[str],\n    before_edges: list[dict[str, str]],\n    after_edges: list[dict[str, str]]\n) -> RenameValidationResult by llm();\n\nsem validate_rename_operation = \"\"\"\nValidate that a rename operation was executed correctly.\n\nCRITICAL CHECKS:\n1. Old task existed in before_nodes (cannot rename non-existent task)\n2. New task is in after_nodes (the renamed task exists)\n3. New task is NOT the same as old task (actual rename occurred)\n4. Old task is NOT in after_nodes (original name removed)\n5. All edges that referenced old_task now reference new_task\n6. No duplicate tasks created\n\nANALYSIS APPROACH:\n- Compare before_nodes and after_nodes to find what changed\n- Check if old_task was removed and new_task was added\n- Verify edge labels are preserved (only task names changed)\n\nExamples:\n- Valid: old=\"IfItIsRainingIWillReadMyBook\" in before, new=\"ReadBook\" in after, edges updated\n- Valid: old=\"MakeCoffee\", new=\"GrabCoffee\", all edges now reference \"GrabCoffee\"\n- Invalid: old task not found in before_nodes\n- Invalid: new task same as old task (no actual rename)\n- Invalid: old task still exists in after_nodes (rename incomplete)\n- Invalid: edges still reference old task (edges not updated)\n\nReturn:\n- is_valid: true if rename was correctly executed\n- reason: Brief explanation of what's wrong (empty if valid)\n- old_task_found: true if old task existed in before_nodes\n- new_task_unique: true if new task doesn't conflict with existing tasks\n- edges_updated: true if all edges were correctly updated\n\"\"\";\n\n\"\"\"Insert validation result\"\"\"\nobj InsertValidationResult {\n    has is_valid: bool;\n    has reason: str;\n    has insert_position_correct: bool;\n    has referring_task_exists: bool;\n    has no_orphans: bool;\n}\n\n\"\"\"Validate that an insert operation positioned tasks correctly\"\"\"\ndef validate_insert_operation(\n    user_message: str,\n    operation_type: str,\n    referring_to_task: str,\n    new_tasks: list[str],\n    before_edges: list[dict[str, str]],\n    after_edges: list[dict[str, str]]\n) -> InsertValidationResult by llm();\n\nsem validate_insert_operation = \"\"\"\nValidate that an insert operation positioned tasks correctly.\n\nOPERATION TYPES:\n- insert_before: New tasks should be BEFORE referring_to_task\n- insert_after: New tasks should be AFTER referring_to_task\n- insert_first: New tasks should be at beginning (after Start)\n\nCRITICAL CHECKS:\n1. Referring task exists in the graph (or is \"Start\" for insert_first)\n2. New tasks were actually added to the graph\n3. Insert position matches the operation type:\n   - insert_before: New task \u2192 referring_to_task edge exists\n   - insert_after: referring_to_task \u2192 new task edge exists\n   - insert_first: Start \u2192 new task edge exists\n4. No orphaned tasks (disconnected from main flow)\n\nANALYSIS APPROACH:\n- Compare before_edges and after_edges to find new edges\n- Check if new edges connect tasks in the correct order\n- Verify the position relative to referring_to_task\n\nExamples:\n- Valid: operation=\"insert_before\", referring=\"CheckMessages\", new=\"WashFace\"\n  \u2192 Edge: WashFace \u2192 CheckMessages exists\n- Valid: operation=\"insert_after\", referring=\"MakeCoffee\", new=\"HaveBreakfast\"\n  \u2192 Edge: MakeCoffee \u2192 HaveBreakfast exists\n- Invalid: referring_to_task not found in graph\n- Invalid: Insert position doesn't match operation type\n- Invalid: New task not connected to graph\n\nReturn:\n- is_valid: true if insert was correctly executed\n- reason: Brief explanation of what's wrong (empty if valid)\n- insert_position_correct: true if position matches operation type\n- referring_task_exists: true if referring task was found\n- no_orphans: true if no disconnected tasks\n\"\"\";\n\n\"\"\"Reorder validation result\"\"\"\nobj ReorderValidationResult {\n    has is_valid: bool;\n    has reason: str;\n    has tasks_moved_exist: bool;\n    has new_order_logical: bool;\n    has no_circular_refs: bool;\n}\n\n\"\"\"Validate that a reorder operation moved tasks correctly\"\"\"\ndef validate_reorder_operation(\n    user_message: str,\n    tasks_to_move: list[str],\n    before_edges: list[dict[str, str]],\n    after_edges: list[dict[str, str]]\n) -> ReorderValidationResult by llm();\n\nsem validate_reorder_operation = \"\"\"\nValidate that a reorder operation moved tasks correctly.\n\nCRITICAL CHECKS:\n1. All tasks in tasks_to_move exist in the graph\n2. New position matches user's description from user_message\n3. No circular references created (A\u2192B\u2192...\u2192A)\n4. All affected tasks remain connected to the main flow\n5. The reorder actually changed something (edges are different)\n\nANALYSIS APPROACH:\n- Identify edges that involve tasks_to_move in before_edges vs after_edges\n- Check if the connections changed as expected\n- Verify the new order matches user's intent\n\nExamples:\n- Valid: tasks=[\"HaveCoffee\"], user: \"have coffee before checking news\"\n  \u2192 Edge: HaveCoffee \u2192 CheckNews exists in after_edges\n- Valid: tasks=[\"WorkOut\", \"Study\"], user: \"work out then study\"\n  \u2192 Edges show correct sequential order\n- Invalid: Task in tasks_to_move not found in graph\n- Invalid: No change in edges (reorder didn't happen)\n- Invalid: Circular reference created\n\nReturn:\n- is_valid: true if reorder was correctly executed\n- reason: Brief explanation of what's wrong (empty if valid)\n- tasks_moved_exist: true if all tasks to move were found\n- new_order_logical: true if new order matches user intent\n- no_circular_refs: true if no circular references detected\n\"\"\";\n\n\"\"\"Edge label validation result\"\"\"\nobj EdgeLabelValidationResult {\n    has is_valid: bool;\n    has reason: str;\n    has missing_labels: list[str];\n    has incorrect_labels: list[str];\n}\n\n\"\"\"Validate that edge labels match user's intent\"\"\"\ndef validate_edge_labels(\n    user_message: str,\n    new_edges: list[dict[str, str]]\n) -> EdgeLabelValidationResult by llm();\n\nsem validate_edge_labels = \"\"\"\nValidate that edge labels match the user's intent from their message.\n\nCRITICAL EDGE LABEL RULES:\n- \"then\" or \"afterwards\": Sequential tasks (A happens, then B happens)\n- \"while\" or \"at same time\": PARALLEL tasks (A and B happen simultaneously)\n- \"if X\" or \"otherwise\": CONDITIONAL branches (if X happens do A, otherwise do B)\n- \"either way\": ONLY for CONDITIONAL convergence where if/otherwise branches merge\n- After PARALLEL tasks converge, use \"then\" or \"afterwards\" (NOT \"either way\")\n\nCHECK FOR COMMON MISTAKES:\n1. \"either way\" used incorrectly (should only be for conditional convergence)\n   - Parallel tasks converging: should use \"then\", not \"either way\"\n   - Sequential tasks: should use \"then\", not \"either way\"\n   - Only valid: \"if X do A; otherwise do B; either way do C\" (A->C, B->C both labeled \"either way\")\n2. Sequential edge missing \"then\" label (has \"either way\" incorrectly)\n3. Conditional branches missing condition labels (\"if X\") or \"otherwise\" labels\n4. Parallel tasks not marked with \"while\" or \"at same time\"\n\nANALYSIS APPROACH:\n- Parse user_message for conditional/parallel keywords\n- Check if new_edges have labels reflecting those keywords\n- Identify which edges are missing labels or have incorrect labels\n\nExamples:\n- Valid: User: \"if raining, read book; otherwise, walk\"\n  \u2192 Edges: [{from: Check, to: ReadBook, label: \"if raining\"}, {to: Walk, label: \"otherwise\"}]\n- Valid: User: \"have drink while chatting, then head home, then call cab\"\n  \u2192 Edges: [{to: HaveDrink, label: \"while\"}, {to: ChatWithBuddies, label: \"while\"},\n           {from: HaveDrink, to: HeadHome, label: \"then\"}, {from: ChatWithBuddies, to: HeadHome, label: \"then\"},\n           {from: HeadHome, to: CallACab, label: \"then\"}]\n- Invalid: Edge from HeadHome to CallACab uses \"either way\" label (should be \"then\")\n- Invalid: \"either way\" used for parallel task convergence (should be \"then\")\n\nReturn:\n- is_valid: true if edge labels match user intent\n- reason: Brief explanation of what's wrong (empty if valid)\n- missing_labels: List of descriptions for missing labels (e.g., [\"condition on 'raining' edge\"])\n- incorrect_labels: List of descriptions for incorrect labels\n\"\"\";\n",
    "pages/HomePage.cl.jac": "import from \"@jac/runtime\" { jacIsLoggedIn, Navigate }\n\ndef:pub HomePage() -> any {\n    if jacIsLoggedIn() {\n        return <Navigate to=\"/app\" />;\n    }\n    return <Navigate to=\"/login\" />;\n}",
    "pages/LoginPage.cl.jac": "# LoginPage Component\n# Login form with username and password\n\nimport from \"@jac/runtime\" { Link }\nimport from ..hooks.useAuth { useAuth }\nimport from ..utils.mergeCls { cn }\nimport from ..components.Layout { Layout }\n\ndef:pub LoginPage() -> any {\n    hook = useAuth();\n    \n    username = hook.username;\n    password = hook.password;\n    error = hook.error;\n    loading = hook.loading;\n    handleLogin = hook.handleLogin;\n    handleUsernameChange = hook.handleUsernameChange;\n    handlePasswordChange = hook.handlePasswordChange;\n    \n    # Error display element\n    errorDisplay = None;\n    if error {\n        errorDisplay = <div className=\"p-3 mb-4 bg-error/10 border border-error/30 rounded-lg text-error text-sm\">\n            {error}\n        </div>;\n    }\n\n    # Input classes with conditional styling\n    inputClass = cn(\n        \"w-full px-4 py-3.5 border-2 rounded-xl text-base transition-all box-border outline-none font-sans\",\n        (\"bg-surface-hover border-border/80\" if loading else \"bg-surface border-border\"),\n        \"text-text-primary placeholder:text-text-secondary\",\n        \"focus:border-primary focus:ring-2 focus:ring-primary/20\"\n    );\n    \n    # Button classes with conditional styling\n    buttonClass = cn(\n        \"w-full py-4 text-primary-foreground border-none rounded-xl text-base font-semibold transition-all flex items-center justify-center gap-2 tracking-wide\",\n        (\"bg-secondary/70 opacity-70 cursor-not-allowed\" if loading else \"bg-secondary cursor-pointer hover:opacity-90\")\n    );\n\n    buttonText = \"Logging in...\" if loading else \"Login\";\n    \n    return <Layout meta={{\"title\": \"Login | Algo\", \"description\": \"Login to your Algo AI assistant account\"}}>\n        <div className=\"flex items-center justify-center min-h-screen p-5 relative overflow-hidden\">\n            <div className=\"absolute inset-0 bg-[radial-gradient(circle_at_20%_50%,rgba(0,0,0,0.03)_0%,transparent_50%),radial-gradient(circle_at_80%_80%,rgba(0,0,0,0.03)_0%,transparent_50%)] pointer-events-none\" />\n\n            <div className=\"bg-surface p-12 rounded-3xl w-full max-w-md shadow-[0_0_0_1px_rgba(0,0,0,0.05),0_20px_60px_rgba(0,0,0,0.08)] relative z-10\">\n                <div className=\"text-center mb-10\">\n                    <h1 className=\"text-4xl font-bold text-text-primary mb-2 tracking-tight\">\n                        {\"Algo\"}\n                    </h1>\n                    <p className=\"text-text-secondary text-base font-normal\">\n                        {\"Your Personal AI Assistant\"}\n                    </p>\n                </div>\n\n                <form onSubmit={handleLogin}>\n                    <div className=\"mb-6\">\n                        <label className=\"block mb-2.5 text-sm font-semibold text-text-primary tracking-wide\">\n                            {\"Username\"}\n                        </label>\n                        <input\n                            type=\"text\"\n                            value={username}\n                            onChange={handleUsernameChange}\n                            placeholder=\"Enter your username\"\n                            disabled={loading}\n                            className={inputClass}\n                        />\n                    </div>\n\n                    <div className=\"mb-8\">\n                        <label className=\"block mb-2.5 text-sm font-semibold text-text-primary tracking-wide\">\n                            {\"Password\"}\n                        </label>\n                        <input\n                            type=\"password\"\n                            value={password}\n                            onChange={handlePasswordChange}\n                            placeholder=\"Enter your password\"\n                            disabled={loading}\n                            className={inputClass}\n                        />\n                    </div>\n\n                    {errorDisplay}\n\n                    <button\n                        type=\"submit\"\n                        disabled={loading}\n                        className={buttonClass}\n                    >\n                        {buttonText}\n                    </button>\n                </form>\n\n                <div className=\"mt-8 text-center text-sm text-text-secondary\">\n                    {\"Don't have an account?\"}\n                    <Link\n                        to=\"/register\"\n                        className=\"ml-1.5 text-primary font-semibold no-underline transition-opacity hover:opacity-80\"\n                    >\n                        {\"Sign up\"}\n                    </Link>\n                </div>\n            </div>\n        </div>\n    </Layout>;\n}",
    "pages/MainApp.cl.jac": "# MainApp Component (UI Only)\n# Pure presentation component - all business logic extracted to useMainApp hook\n\nimport from react { Fragment }\n\nimport from ..components.TranscriptItem { TranscriptItem }\nimport from ..components.Header { Header }\nimport from ..components.MessageInput { MessageInput }\nimport from ..components.ControlBar { ControlBar }\nimport from ..components.GraphViewer { GraphViewer }\nimport from ..components.Layout { Layout }\n\nimport from ..hooks.useMainApp { useMainApp }\nimport from ..utils.mergeCls { cn }\n\n# ============================================\n# Main Application Component\n# ============================================\n\ndef:pub MainApp() -> any {\n    # Thinking insights toggle state (local to UI) - using new has syntax\n    has showThinking: bool = True;\n\n    def toggleThinking() -> None {\n        showThinking = not showThinking;\n    }\n\n    # Get all state and handlers from the hook\n    hook = useMainApp();\n\n    # Destructure hook values for cleaner access\n    sessionStatus = hook.sessionStatus;\n    isPTTActive = hook.isPTTActive;\n    setIsPTTActive = hook.setIsPTTActive;\n    isPTTUserSpeaking = hook.isPTTUserSpeaking;\n    isAudioPlaybackEnabled = hook.isAudioPlaybackEnabled;\n    setIsAudioPlaybackEnabled = hook.setIsAudioPlaybackEnabled;\n    isMicMuted = hook.isMicMuted;\n    userText = hook.userText;\n    setUserText = hook.setUserText;\n    transcript = hook.transcript;\n    graphDotCode = hook.graphDotCode;\n    transcriptEndRef = hook.transcriptEndRef;\n    suggestions = hook.suggestions;\n\n    # Handlers\n    onToggleConnection = hook.onToggleConnection;\n    toggleMicMute = hook.toggleMicMute;\n    handleTalkButtonDown = hook.handleTalkButtonDown;\n    handleTalkButtonUp = hook.handleTalkButtonUp;\n    handleSendTextMessage = hook.handleSendTextMessage;\n    handleSuggestionClick = hook.handleSuggestionClick;\n    handleClearGraph = hook.handleClearGraph;\n    handleSaveAndRestart = hook.handleSaveAndRestart;\n\n    # Build transcript items\n    transcriptItems = transcript.map(lambda item: any, idx: int -> any {\n        return <TranscriptItem key={idx} item={item} showThinking={showThinking} />;\n    });\n    \n    # ========== Render ==========\n    return <Layout meta={{\"title\": \"Dashboard | Algo\", \"description\": \"Your AI assistant dashboard with voice interface\"}}>\n        <div className=\"flex flex-col h-screen\">\n            <Header showThinking={showThinking} onToggleThinking={toggleThinking} />\n            \n            <div className=\"flex-1 flex gap-2 p-2 overflow-hidden\">\n                <TranscriptPanel \n                    transcriptItems={transcriptItems}\n                    transcriptEndRef={transcriptEndRef}\n                    userText={userText}\n                    setUserText={setUserText}\n                    onSend={handleSendTextMessage}\n                    suggestions={suggestions}\n                    onSelectSuggestion={handleSuggestionClick}\n                    sessionStatus={sessionStatus}\n                    onToggleConnection={onToggleConnection}\n                />\n                \n                <GraphPanel \n                    graphDotCode={graphDotCode}\n                    onClearGraph={handleClearGraph}\n                />\n            </div>\n            \n            <ControlBar\n                sessionStatus={sessionStatus}\n                isPTTActive={isPTTActive}\n                setIsPTTActive={setIsPTTActive}\n                isPTTUserSpeaking={isPTTUserSpeaking}\n                onTalkDown={handleTalkButtonDown}\n                onTalkUp={handleTalkButtonUp}\n                isAudioPlaybackEnabled={isAudioPlaybackEnabled}\n                setIsAudioPlaybackEnabled={setIsAudioPlaybackEnabled}\n                isMicMuted={isMicMuted}\n                onToggleMicMute={toggleMicMute}\n                onSaveAndRestart={handleSaveAndRestart}\n            />\n        </div>\n    </Layout>;\n}\n\n# ============================================\n# Sub-Components (Presentational)\n# ============================================\n\n# Transcript Panel - left side showing conversation\ndef TranscriptPanel(\n    transcriptItems: any,\n    transcriptEndRef: any,\n    userText: str,\n    setUserText: any,\n    onSend: any,\n    suggestions: list,\n    onSelectSuggestion: any,\n    sessionStatus: str,\n    onToggleConnection: any\n) -> any {\n    return <div className=\"flex-1 bg-surface rounded-xl flex flex-col min-h-0 shadow-sm\">\n        <div className=\"flex items-center justify-between px-6 py-3 border-b border-border font-semibold text-text-primary\">\n            {\"Transcript\"}\n        </div>\n        \n        <div className=\"flex-1 overflow-y-auto p-4 flex flex-col gap-4\">\n            {transcriptItems}\n            <div ref={transcriptEndRef} />\n        </div>\n        \n        <MessageInput \n            userText={userText}\n            setUserText={setUserText}\n            onSend={onSend}\n            suggestions={suggestions}\n            onSelectSuggestion={onSelectSuggestion}\n            sessionStatus={sessionStatus}\n            onToggleConnection={onToggleConnection}\n        />\n    </div>;\n}\n\n# Graph Panel - right side showing task visualization\ndef GraphPanel(graphDotCode: str, onClearGraph: any) -> any {\n    return <div className=\"flex-1 bg-surface rounded-xl flex flex-col min-h-0 shadow-sm\">\n        <div className=\"flex items-center justify-between px-6 py-3 border-b border-border font-semibold text-text-primary\">\n            {\"Task Graph\"}\n            <span className=\"text-xs text-text-secondary font-normal\">\n                {\"Real-time visualization\"}\n            </span>\n        </div>\n        \n        <div className=\"flex-1 overflow-auto bg-surface-hover relative\">\n            <GraphViewer dotCode={graphDotCode} />\n            \n            <ClearGraphButton onClick={onClearGraph} />\n        </div>\n    </div>;\n}\n\n# Clear Graph Button\ndef ClearGraphButton(onClick: any) -> any {\n    return <button\n        onClick={onClick}\n        className=\"absolute bottom-4 right-4 px-4 py-2 bg-error text-error-foreground border-none rounded-lg cursor-pointer text-sm font-medium shadow-md transition-all hover:opacity-90 hover:-translate-y-0.5 active:translate-y-0\"\n    >\n        {\"Clear Graph\"}\n    </button>;\n}\n",
    "pages/RegisterPage.cl.jac": "# RegisterPage Component\n# Registration form with username, password, and confirm password\n\nimport from \"@jac/runtime\" { Link }\nimport from ..hooks.useAuth { useAuth }\nimport from ..utils.mergeCls { cn }\nimport from ..components.Layout { Layout }\n\ndef:pub RegisterPage() -> any {\n    # Call Hook (Get All Logic)\n    hook = useAuth();\n    \n    # Destructure for easier access\n    username = hook.username;\n    password = hook.password;\n    confirmPassword = hook.confirmPassword;\n    error = hook.error;\n    loading = hook.loading;\n    handleRegister = hook.handleRegister;\n    handleUsernameChange = hook.handleUsernameChange;\n    handlePasswordChange = hook.handlePasswordChange;\n    handleConfirmPasswordChange = hook.handleConfirmPasswordChange;\n    \n    # Error display element\n    errorDisplay = None;\n    if error {\n        errorDisplay = <div className=\"p-3 mb-4 bg-error/10 border border-error/30 rounded-lg text-error text-sm\">\n            {error}\n        </div>;\n    }\n\n    # Input classes with conditional styling\n    inputClass = cn(\n        \"w-full px-4 py-3.5 border-2 rounded-xl text-base transition-all box-border outline-none font-sans\",\n        (\"bg-surface-hover border-border/80\" if loading else \"bg-surface border-border\"),\n        \"text-text-primary placeholder:text-text-secondary\",\n        \"focus:border-primary focus:ring-2 focus:ring-primary/20\"\n    );\n    \n    # Button classes with conditional styling\n    buttonClass = cn(\n        \"w-full py-4 text-primary-foreground border-none rounded-xl text-base font-semibold transition-all flex items-center justify-center gap-2 tracking-wide\",\n        (\"bg-secondary/70 opacity-70 cursor-not-allowed\" if loading else \"bg-secondary cursor-pointer hover:opacity-90\")\n    );\n\n    buttonText = \"Creating account...\" if loading else \"Sign up\";\n\n    # Render (UI Only) \n    return <Layout meta={{\"title\": \"Register | Algo\", \"description\": \"Create your Algo AI assistant account\"}}>\n        <div className=\"flex items-center justify-center min-h-screen p-5 relative overflow-hidden\">\n            <div className=\"absolute inset-0 bg-[radial-gradient(circle_at_20%_50%,rgba(0,0,0,0.03)_0%,transparent_50%),radial-gradient(circle_at_80%_80%,rgba(0,0,0,0.03)_0%,transparent_50%)] pointer-events-none\" />\n\n            <div className=\"bg-surface p-12 rounded-3xl w-full max-w-md shadow-[0_0_0_1px_rgba(0,0,0,0.05),0_20px_60px_rgba(0,0,0,0.08)] relative z-10\">\n                <div className=\"text-center mb-10\">\n                    <h1 className=\"text-4xl font-bold text-text-primary mb-2 tracking-tight\">\n                        {\"Algo\"}\n                    </h1>\n                    <p className=\"text-text-secondary text-base font-normal\">\n                        {\"Create your account\"}\n                    </p>\n                </div>\n\n                <form onSubmit={handleRegister}>\n                    <div className=\"mb-5\">\n                        <label className=\"block mb-2.5 text-sm font-semibold text-text-primary tracking-wide\">\n                            {\"Username\"}\n                        </label>\n                        <input\n                            type=\"text\"\n                            value={username}\n                            onChange={handleUsernameChange}\n                            placeholder=\"Choose a username\"\n                            disabled={loading}\n                            className={inputClass}\n                        />\n                    </div>\n\n                    <div className=\"mb-5\">\n                        <label className=\"block mb-2.5 text-sm font-semibold text-text-primary tracking-wide\">\n                            {\"Password\"}\n                        </label>\n                        <input\n                            type=\"password\"\n                            value={password}\n                            onChange={handlePasswordChange}\n                            placeholder=\"Choose a password (min 6 characters)\"\n                            disabled={loading}\n                            className={inputClass}\n                        />\n                    </div>\n\n                    <div className=\"mb-8\">\n                        <label className=\"block mb-2.5 text-sm font-semibold text-text-primary tracking-wide\">\n                            {\"Confirm Password\"}\n                        </label>\n                        <input\n                            type=\"password\"\n                            value={confirmPassword}\n                            onChange={handleConfirmPasswordChange}\n                            placeholder=\"Re-enter your password\"\n                            disabled={loading}\n                            className={inputClass}\n                        />\n                    </div>\n\n                    {errorDisplay}\n\n                    <button\n                        type=\"submit\"\n                        disabled={loading}\n                        className={buttonClass}\n                    >\n                        {buttonText}\n                    </button>\n                </form>\n\n                <div className=\"mt-8 text-center text-sm text-text-secondary\">\n                    {\"Already have an account?\"}\n                    <Link\n                        to=\"/login\"\n                        className=\"ml-1.5 text-primary font-semibold no-underline transition-opacity hover:opacity-80\"\n                    >\n                        {\"Login\"}\n                    </Link>\n                </div>\n            </div>\n        </div>\n    </Layout>;\n}",
    "service/mainAppService.impl.jac": "import from datetime { datetime }\nimport from time { time }\n\nimpl get_session_token.fetch {\n    try {\n        api_key = getenv(\"OPENAI_API_KEY\");\n        if not api_key {\n            report {\"error\": \"OPENAI_API_KEY not set in environment\"} ;\n            return;\n        }\n\n        url = \"https://api.openai.com/v1/realtime/client_secrets\";\n        request_data = dumps(\n            {\"session\": {\"type\": \"realtime\", \"model\": \"gpt-realtime\"}}\n        );\n\n        req = Request(\n            url,\n            data=request_data.encode('utf-8'),\n            headers={\n                \"Authorization\": f\"Bearer {api_key}\",\n                \"Content-Type\": \"application/json\"\n            },\n            method=\"POST\"\n        );\n\n        response = urlopen(req);\n        data = loads(response.read().decode('utf-8'));\n\n        if \"value\" in data {\n            report {\"key\": data[\"value\"]} ;\n        } else {\n            report {\"error\": \"Failed to fetch key\", \"details\": data} ;\n        }\n    } except HTTPError as e {\n        error_msg = e.read().decode('utf-8') if e?.read else str(e);\n        report {\"error\": f\"HTTP Error: {e.code}\", \"details\": error_msg} ;\n    } except URLError as e {\n        report {\"error\": \"URL Error\", \"details\": str(e.reason)} ;\n    } except Exception as e {\n        report {\"error\": \"Server error\", \"details\": str(e)} ;\n    }\n}\n\n# WALKER: init_user_graph\nimpl init_user_graph.initialize{\n    visit [-->](`?user_graph_data) else {\n        (here ++> user_graph_data()) ++> TaskState(task_name=\"Start\");\n    }\n    visit [-->](`?manager_comm_data) else {\n        here ++> manager_comm_data();\n    }\n    visit [-->](`?user_routines) else { here ++> user_routines(); }\n}\n\n# WALKER: update_task_graph\nimpl update_task_graph.navigate_to_graph{\n    user_graph = find_user_graph(here, self.username);\n    if not user_graph {\n        user_graph = here ++> user_graph_data(username=self.username);\n    }\n    visit user_graph;\n}\n\nimpl update_task_graph.update_graph {\n    prev_node = None;\n    all_task_nodes = [-->](`?TaskState);\n    nodes_to_check = all_task_nodes.copy();\n    all_nodes = [];\n    \n    # Collect all nodes via traversal\n    visited_ids = {};\n\n    while len(nodes_to_check) > 0 {\n        current = nodes_to_check.pop(0);\n        if hasattr(current, 'task_name') {\n            # Use object id to track unique nodes (not task_name)\n            node_id = id(current);\n            if node_id not in visited_ids {\n                visited_ids[node_id] = True;\n                all_nodes.append(current);\n                # Get successors via TaskFlow edges\n                successors = [current-->](`?TaskState);\n                for succ in successors {\n                    nodes_to_check.append(succ);\n                }\n            }\n        }\n    }\n\n    most_recent_time = None;\n    for node in all_nodes {\n        if node.task_name == self.previous_task {\n            if hasattr(node, 'created_at') and node.created_at {\n                if most_recent_time == None or node.created_at > most_recent_time {\n                    most_recent_time = node.created_at;\n                    prev_node = node;\n                }\n            } else {\n                if prev_node == None {\n                    prev_node = node;\n                }\n            }\n        }\n    }\n\n    if prev_node == None {\n        prev_node = TaskState(task_name=self.previous_task);\n        if self.previous_task == \"Start\" {\n            here ++> prev_node;\n        }\n    }\n\n    new_node = TaskState(\n        task_name=self.task_name,\n        created_at=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    );\n    here ++> new_node;\n    prev_node +>: TaskFlow(label=self.edge_label) :+> new_node;\n    here.last_task = self.task_name;\n\n    graph_data = get_graph_structure(here);\n    report {\n        \"success\": True,\n        \"message\": f\"Added task '{self.task_name}' connected from '{self.previous_task}'\",\n        \"dotCode\": graph_data[2],\n        \"nodes\": graph_data[0],\n        \"edges\": graph_data[1]\n    } ;\n}\n\n# WALKER: get_task_graph\nimpl get_task_graph.navigate_to_graph{\n    user_graph = find_user_graph(here, self.username);\n    if not user_graph {\n        report {\"nodes\": [], \"edges\": [], \"dotCode\": \"\", \"lastTask\": \"Start\"} ;\n        disengage;\n    }\n    visit user_graph;\n}\n\nimpl get_task_graph.get_graph{\n    result = get_user_graph_structure(here);\n    node_list = result[0];\n    edge_list = result[1];\n    dot_code = generate_dot_code_from_lists(node_list, edge_list);\n\n    leaf_nodes = find_leaf_nodes(edge_list, node_list);\n    last_task_to_report = (leaf_nodes[0] if len(leaf_nodes) == 1\n                           else \"|\".join(leaf_nodes) if leaf_nodes\n                           else here.last_task);\n\n    report {\n        \"nodes\": node_list,\n        \"edges\": edge_list,\n        \"dotCode\": dot_code,\n        \"lastTask\": last_task_to_report\n    } ;\n}\n\n# WALKER: clear_graph\nimpl clear_graph.navigate_to_graph{\n    user_graph = find_user_graph(here, self.username);\n    if not user_graph {\n        report {\"success\": True, \"message\": \"No graph to clear\"} ;\n        disengage;\n    }\n    visit user_graph;\n}\n\nimpl clear_graph.clear_data{\n    for node in [-->](`?TaskState) { del node; }\n    here ++> TaskState(task_name=\"Start\");\n    here.last_task = \"Start\";\n    report {\"success\": True, \"message\": \"Graph cleared successfully\"} ;\n}\n\n# WALKER: save_routine\nimpl save_routine.navigate_to_graph{\n    user_graph = find_user_graph(here, self.username);\n    if not user_graph {\n        report {\"error\": \"No graph to save\", \"success\": False} ;\n        disengage;\n    }\n    visit user_graph;\n}\n\nimpl save_routine.save_routine_data{\n    if not here?.saved_routines { here.saved_routines = {}; }\n\n    timestamp = str(time());\n    graph_data = get_graph_structure(here);\n    here.saved_routines[self.routine_name] = {\n        \"nodes\": graph_data[0].copy(),\n        \"edges\": graph_data[1].copy(),\n        \"saved_at\": timestamp\n    };\n\n    node_count = 0;\n    for _ in graph_data[0] {\n        node_count = node_count + 1;\n    }\n\n    report {\n        \"success\": True,\n        \"message\": f\"Saved routine with {node_count} tasks\",\n        \"routine\": here.saved_routines[self.routine_name]\n    } ;\n}\n\n# WALKER: load_past_routines\nimpl load_past_routines.navigate_to_routines{\n    all_routines = [-->](`?user_routines);\n    user_routines_node = None;\n    for r in all_routines {\n        if r?.username and r.username == self.username {\n            user_routines_node = r;\n            break;\n        }\n    }\n    if user_routines_node == None {\n        report {\"routines\": {}, \"count\": 0, \"message\": \"No past routines saved yet\"} ;\n        disengage;\n    }\n    visit user_routines_node;\n}\n\nimpl load_past_routines.load_routines{\n    routine_count = 0;\n    for _ in here.routines {\n        routine_count = routine_count + 1;\n    }\n    if routine_count == 0 {\n        report {\"routines\": {}, \"count\": 0, \"message\": \"No past routines saved yet\"} ;\n    } else {\n        report {\n            \"routines\": here.routines,\n            \"count\": routine_count,\n            \"message\": f\"Loaded {routine_count} saved routine(s)\"\n        } ;\n    }\n}\n\n# WALKER: reset_session\nimpl reset_session.navigate_to_graph{\n    user_graph = find_user_graph(here, self.username);\n    if not user_graph {\n        report {\"success\": True, \"message\": \"Session already empty.\"} ;\n        disengage;\n    }\n    visit user_graph;\n}\n\nimpl reset_session.reset_graph{\n    for node in [-->](`?TaskState) { del node; }\n    here ++> TaskState(task_name=\"Start\");\n    here.last_task = \"Start\";\n    report {\"success\": True, \"message\": \"Session reset. Ready for a new conversation.\"} ;\n}\n\n# WALKER: rebuild_graph\nimpl rebuild_graph.navigate_to_graph{\n    user_graph = find_user_graph(here, self.username);\n    if not user_graph {\n        user_graph = here ++> user_graph_data(username=self.username);\n    }\n    visit user_graph;\n}\n\nimpl rebuild_graph.rebuild{\n    all_task_nodes = [-->](`?TaskState);\n    for node in all_task_nodes {\n        del node ;\n    }\n\n    node_map = {};\n    for node_name in self.new_nodes {\n        new_task = TaskState(\n            task_name=node_name,\n            created_at=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        );\n        node_map[node_name] = new_task;\n        here ++> new_task;\n    }\n\n    for edge_spec in self.new_edges {\n        from_name = edge_spec.get(\"from\", \"\");\n        to_name = edge_spec.get(\"to\", \"\");\n        edge_label = edge_spec.get(\"label\", \"\");\n\n        if from_name in node_map and to_name in node_map {\n            from_node = node_map[from_name];\n            to_node = node_map[to_name];\n            from_node +>: TaskFlow(label=edge_label) :+> to_node;\n        }\n    }\n\n    here.last_task = (self.new_nodes[-1] if self.new_nodes and len(self.new_nodes) > 0 else \"Start\");\n    dot_code = generate_dot_code_from_lists(self.new_nodes, self.new_edges);\n    report {\n        \"success\": True,\n        \"message\": \"Graph rebuilt successfully\",\n        \"dotCode\": dot_code,\n        \"nodes\": self.new_nodes,\n        \"edges\": self.new_edges\n    } ;\n}\n\n# WALKER: rename_task\nimpl rename_task.navigate_to_graph{\n    user_graph = find_user_graph(here, self.username);\n    if not user_graph {\n        report {\"success\": False, \"error\": \"No graph found to rename tasks in\"} ;\n        disengage;\n    }\n    visit user_graph;\n}\n\nimpl rename_task.rename{\n    all_task_nodes = [-->](`?TaskState);\n    target_node = None;\n\n    for node in all_task_nodes {\n        if node?.task_name and node.task_name == self.old_name {\n            target_node = node;\n            break;\n        }\n    }\n\n    if not target_node {\n        report {\"success\": False, \"error\": f\"Task '{self.old_name}' not found in graph\"} ;\n        return;\n    }\n\n    target_node.task_name = self.new_name;\n    if here.last_task == self.old_name { here.last_task = self.new_name; }\n\n    graph_data = get_graph_structure(here);\n\n    report {\n        \"success\": True,\n        \"message\": f\"Renamed '{self.old_name}' to '{self.new_name}'\",\n        \"dotCode\": graph_data[2],\n        \"nodes\": graph_data[0],\n        \"edges\": graph_data[1]\n    } ;\n}\n\n# WALKER: call_graph_agent\nimpl call_graph_agent.call{\n    try {\n        api_key = getenv(\"OPENAI_API_KEY\");\n        if not api_key {\n            report {\"error\": \"OPENAI_API_KEY not set\"} ;\n            return;\n        }\n\n        # Load current graph state\n        current_nodes = [];\n        current_edges = [];\n        last_task = \"Start\";\n\n        user_graph = find_user_graph(here, self.username);\n        if not user_graph {\n            user_graph = here ++> user_graph_data(username=self.username);\n            user_graph ++> TaskState(task_name=\"Start\");\n        }\n\n        if user_graph {\n            last_task = user_graph?.last_task or \"Start\";\n            start_node = find_start_node(user_graph);\n\n            if start_node {\n                graph_data = get_user_graph_structure(user_graph);\n                current_nodes = graph_data[0];\n                current_edges = graph_data[1];\n\n                leaf_nodes = find_leaf_nodes(current_edges, current_nodes);\n                if len(leaf_nodes) > 1 {\n                    last_task = \"|\".join(leaf_nodes);\n                } elif len(leaf_nodes) == 1 {\n                    last_task = leaf_nodes[0];\n                } else {\n                    current_nodes = [\"Start\"];\n                }\n            } else {\n                current_nodes = [\"Start\"];\n            }\n        } else {\n            current_nodes = [\"Start\"];\n        }\n\n        before_nodes = current_nodes.copy();\n        before_edges = current_edges.copy();\n\n        emotional_state = detect_emotional_state(\n            user_message=self.context_from_user,\n            conversation_history=self.conversation_history\n        );\n\n        intent_analysis = analyze_conversation_intent(\n            user_message=self.context_from_user,\n            conversation_history=self.conversation_history,\n            existing_nodes=current_nodes,\n            last_task=last_task\n        );\n\n        if intent_analysis.conversation_context.correction_type == \"rename\" {\n            referring_to = intent_analysis.conversation_context.referring_to_task;\n\n            old_name = None;\n            if referring_to and referring_to in current_nodes {\n                old_name = referring_to;\n            } else {\n                for node in current_nodes {\n                    if referring_to and node.lower() == referring_to.lower() {\n                        old_name = node;\n                        break;\n                    }\n                }\n                if not old_name {\n                    old_name = last_task.split(\"|\")[0] if \"|\" in last_task else last_task;\n                }\n            }\n\n            extracted_tasks = extract_raw_task_names(\n                user_message=self.context_from_user,\n                conversation_context=intent_analysis.conversation_context,\n                existing_nodes=current_nodes\n            );\n\n            new_name = extracted_tasks.renamed_to;\n\n            if old_name != \"Start\" and new_name {\n                new_nodes = [new_name if n == old_name else n for n in current_nodes];\n                new_edges = [\n                    {\n                        \"from\": new_name if e.get(\"from\") == old_name else e.get(\"from\"),\n                        \"to\": new_name if e.get(\"to\") == old_name else e.get(\"to\"),\n                        \"label\": e.get(\"label\", \"\")\n                    }\n                    for e in current_edges\n                ];\n\n                here spawn rebuild_graph(username=self.username, new_nodes=new_nodes, new_edges=new_edges);\n\n                intent_dict = {\n                    \"conversation_context\": {\n                        \"intent\": str(intent_analysis.conversation_context.intent),\n                        \"referring_to_task\": intent_analysis.conversation_context.referring_to_task,\n                        \"correction_type\": intent_analysis.conversation_context.correction_type,\n                        \"needs_graph_rebuild\": intent_analysis.conversation_context.needs_graph_rebuild,\n                        \"is_insertion\": intent_analysis.conversation_context.is_insertion,\n                        \"tasks_to_move\": intent_analysis.conversation_context.tasks_to_move\n                    },\n                    \"should_create_tasks\": intent_analysis.should_create_tasks,\n                    \"confidence\": intent_analysis.confidence\n                };\n\n                root spawn validate_graph_output(\n                    context_from_user=self.context_from_user,\n                    username=self.username,\n                    intent_analysis=intent_dict,\n                    extracted_tasks=[new_name],\n                    before_nodes=before_nodes,\n                    before_edges=before_edges,\n                    after_nodes=new_nodes,\n                    after_edges=new_edges\n                );\n\n                response = generate_friendly_response(self.context_from_user, emotional_state, \"task_renamed\", [new_name]);\n\n                manager_data = find_manager_comm_data(here, self.username);\n                if not manager_data {\n                    manager_data = here ++> manager_comm_data(username=self.username);\n                }\n                manager_data.last_response = response;\n                manager_data.last_suggestions = [];\n                manager_data.last_thinking = {\n                    \"emotional\": f\"You seem {emotional_state.state} right now\",\n                    \"intent\": \"You're renaming a task\",\n                    \"tasks\": f\"Renamed: {old_name} \u2192 {new_name}\",\n                    \"pattern\": \"\"\n                };\n                manager_data.last_task_names = [new_name];\n                manager_data.last_emotional_state = emotional_state.state;\n\n                report {\n                    \"response\": response,\n                    \"emotional_state\": emotional_state.state,\n                    \"suggestions\": [],\n                    \"thinking\": manager_data.last_thinking,\n                    \"task_names\": [new_name],\n                    \"validation_passed\": True\n                };\n                return;\n            }\n        }\n\n        relationships = [];\n        extracted_tasks = None;\n        attachment_analysis = None;\n        convergence_intent = None;\n        edge_to_split = None;\n\n        if intent_analysis.should_create_tasks {\n            extracted_tasks = extract_raw_task_names(\n                user_message=self.context_from_user,\n                conversation_context=intent_analysis.conversation_context,\n                existing_nodes=current_nodes\n            );\n\n            correction_type = intent_analysis.conversation_context.correction_type;\n            referring_to = intent_analysis.conversation_context.referring_to_task;\n\n            if correction_type in [\"insert_before\", \"insert_after\", \"insert_first\"] {\n                if correction_type == \"insert_before\" and referring_to {\n                    for edge in current_edges {\n                        if edge.get(\"to\") == referring_to {\n                            last_task = edge.get(\"from\");\n                            edge_to_split = edge;\n                            break;\n                        }\n                    }\n                } elif correction_type == \"insert_after\" and referring_to {\n                    last_task = referring_to;\n                    edge_to_split = next((e for e in current_edges if e.get(\"from\") == referring_to), None);\n                } elif correction_type == \"insert_first\" {\n                    last_task = \"Start\";\n                }\n            }\n\n            attachment_analysis = determine_attachment_points(\n                user_message=self.context_from_user,\n                last_task=last_task,\n                existing_nodes=current_nodes,\n                conversation_context=intent_analysis.conversation_context\n            );\n\n            convergence_intent = detect_convergence_intent(\n                user_message=self.context_from_user,\n                last_task=last_task,\n                current_edges=current_edges\n            );\n\n            relationships = build_task_relationships(\n                user_message=self.context_from_user,\n                extracted_tasks=extracted_tasks,\n                attachment_analysis=attachment_analysis,\n                convergence_intent=convergence_intent,\n                conversation_context=intent_analysis.conversation_context,\n                current_edges=current_edges\n            );\n\n            if intent_analysis.conversation_context.needs_graph_rebuild\n            and len(current_nodes) > 1 {\n                all_nodes = [\"Start\"];\n                added_nodes = {\"Start\": True};\n\n                for rel in relationships {\n                    if rel.from_task not in added_nodes {\n                        all_nodes.append(rel.from_task);\n                        added_nodes[rel.from_task] = True;\n                    }\n                    if rel.to_task not in added_nodes {\n                        all_nodes.append(rel.to_task);\n                        added_nodes[rel.to_task] = True;\n                    }\n                }\n\n                for node in current_nodes {\n                    if node not in added_nodes and node != \"Start\" {\n                        all_nodes.append(node);\n                        added_nodes[node] = True;\n                    }\n                }\n\n                edge_map = {};\n                tasks_to_move = intent_analysis.conversation_context.tasks_to_move if hasattr(intent_analysis.conversation_context, 'tasks_to_move') else [];\n\n                if len(tasks_to_move) > 0 {\n                    for edge in current_edges {\n                        from_task = edge.get(\"from\", \"\");\n                        to_task = edge.get(\"to\", \"\");\n\n                        involves_moved_task = False;\n                        for moved_task in tasks_to_move {\n                            if from_task == moved_task or to_task == moved_task {\n                                involves_moved_task = True;\n                                break;\n                            }\n                        }\n\n                        if not involves_moved_task {\n                            edge_key = f\"{from_task}->{to_task}\";\n                            edge_map[edge_key] = edge;\n                        }\n                    }\n                } else {\n                    for edge in current_edges {\n                        from_task = edge.get(\"from\", \"\");\n                        to_task = edge.get(\"to\", \"\");\n                        edge_key = f\"{from_task}->{to_task}\";\n                        edge_map[edge_key] = edge;\n                    }\n\n                    if edge_to_split {\n                        split_key = f\"{edge_to_split.get('from', '')}->{edge_to_split.get('to', '')}\";\n                        if split_key in edge_map {\n                            del edge_map[split_key];\n                        }\n                    }\n\n                    edges_to_remove = {};\n                    for rel in relationships {\n                        for other_rel in relationships {\n                            if rel.to_task == other_rel.from_task {\n                                direct_edge_key = f\"{rel.from_task}->{other_rel.to_task}\";\n                                if direct_edge_key in edge_map {\n                                    edges_to_remove[direct_edge_key] = True;\n                                }\n                            }\n                        }\n                    }\n\n                    for edge_key in edges_to_remove {\n                        if edge_key in edge_map {\n                            del edge_map[edge_key];\n                        }\n                    }\n                }\n\n                for rel in relationships {\n                    edge_key = f\"{rel.from_task}->{rel.to_task}\";\n                    edge_map[edge_key] = {\n                        \"from\": rel.from_task,\n                        \"to\": rel.to_task,\n                        \"label\": rel.edge_label\n                    };\n                }\n\n                new_edges = [];\n                for edge_key in edge_map {\n                    new_edges.append(edge_map[edge_key]);\n                }\n                here spawn rebuild_graph(\n                    username=self.username, new_nodes=all_nodes, new_edges=new_edges\n                );\n            } else {\n                sorted_rels = [];\n                for rel in relationships {\n                    inserted = False;\n                    for i in range(len(sorted_rels)) {\n                        if rel.sequence_order < sorted_rels[i].sequence_order {\n                            sorted_rels.insert(i, rel);\n                            inserted = True;\n                            break;\n                        }\n                    }\n                    if not inserted {\n                        sorted_rels.append(rel);\n                    }\n                }\n                for rel in sorted_rels {\n                    here spawn update_task_graph(\n                        task_name=rel.to_task,\n                        previous_task=rel.from_task,\n                        edge_label=rel.edge_label,\n                        username=self.username\n                    );\n                }\n            }\n        }\n\n        thinking_summary = generate_thinking_summary(\n            user_message=self.context_from_user,\n            emotional_state=emotional_state,\n            intent_analysis=intent_analysis,\n            extracted_tasks=extracted_tasks,\n            attachment_analysis=attachment_analysis,\n            convergence_intent=convergence_intent\n        );\n\n        task_names = [];\n        for rel in relationships {\n            if rel.to_task not in task_names {\n                task_names.append(rel.to_task);\n            }\n        }\n\n        response = generate_friendly_response(\n            user_message=self.context_from_user,\n            emotional_state=emotional_state,\n            action_taken=\"task_added\" if intent_analysis.should_create_tasks else \"none\",\n            task_names=task_names\n        );\n\n        suggestions = [];\n        try {\n            recent_tasks = [];\n            task_count = 0;\n            for i in range(len(current_nodes) - 1, -1, -1) {\n                if current_nodes[i] != \"Start\" and task_count < 3 {\n                    recent_tasks.insert(0, current_nodes[i]);\n                    task_count = task_count + 1;\n                }\n            }\n\n            suggestions = generate_next_suggestions(\n                last_task=last_task,\n                recent_tasks=recent_tasks,\n                conversation_context=self.context_from_user,\n                emotional_state=emotional_state.state\n            );\n        } except Exception as e {\n            suggestions = [];\n        }\n\n        thinking = {\n            \"emotional\": thinking_summary.emotional_insight if thinking_summary.emotional_insight else \"\",\n            \"intent\": thinking_summary.intent_insight if thinking_summary.intent_insight else \"\",\n            \"tasks\": thinking_summary.task_insight if thinking_summary.task_insight else \"\",\n            \"pattern\": thinking_summary.pattern_insight if thinking_summary.pattern_insight else \"\"\n        };\n\n        user_graph_after = find_user_graph(here, self.username);\n        after_nodes = [];\n        after_edges = [];\n        if user_graph_after {\n            graph_data = get_user_graph_structure(user_graph_after);\n            after_nodes = graph_data[0];\n            after_edges = graph_data[1];\n        }\n\n        manager_data = find_manager_comm_data(here, self.username);\n        if not manager_data {\n            manager_data = here ++> manager_comm_data(username=self.username);\n        }\n        manager_data.last_response = response;\n        manager_data.last_suggestions = suggestions;\n        manager_data.last_thinking = thinking;\n        manager_data.last_task_names = task_names;\n        manager_data.last_emotional_state = emotional_state.state;\n\n        intent_dict = {\n            \"conversation_context\": {\n                \"intent\": str(intent_analysis.conversation_context.intent),\n                \"referring_to_task\": intent_analysis.conversation_context.referring_to_task,\n                \"correction_type\": intent_analysis.conversation_context.correction_type,\n                \"needs_graph_rebuild\": intent_analysis.conversation_context.needs_graph_rebuild,\n                \"is_insertion\": intent_analysis.conversation_context.is_insertion,\n                \"tasks_to_move\": intent_analysis.conversation_context.tasks_to_move\n            },\n            \"should_create_tasks\": intent_analysis.should_create_tasks,\n            \"confidence\": intent_analysis.confidence\n        };\n\n        root spawn validate_graph_output(\n            context_from_user=self.context_from_user,\n            username=self.username,\n            intent_analysis=intent_dict,\n            extracted_tasks=task_names,\n            before_nodes=before_nodes,\n            before_edges=before_edges,\n            after_nodes=after_nodes,\n            after_edges=after_edges\n        );\n\n        # Read validation result from manager_comm_data\n        validation_failed = False;\n        validation_reason = \"\";\n        validation_type = \"\";\n        missing_tasks = [];\n\n        if not manager_data.validation_passed {\n            validation_failed = True;\n            validation_reason = manager_data.validation_reason;\n            validation_type = manager_data.validation_type or \"\";\n            missing_tasks = manager_data.missing_tasks or [];\n        }\n\n        if validation_failed {\n            if validation_type == \"task_rename\" {\n                incorrect_task = manager_data.incorrect_task or \"\";\n                correct_task_name = manager_data.correct_task_name or \"\";\n\n                if incorrect_task and correct_task_name {\n                    here spawn rename_task(\n                        old_name=incorrect_task,\n                        new_name=correct_task_name,\n                        username=self.username\n                    );\n\n                    # Update task_names to reflect the renamed task\n                    for i in range(len(task_names)) {\n                        if task_names[i] == incorrect_task {\n                            task_names[i] = correct_task_name;\n                        }\n                    }\n\n                    response = f\"{response} I've renamed '{incorrect_task}' to '{correct_task_name}'.\";\n\n                    report {\n                        \"response\": response,\n                        \"emotional_state\": emotional_state.state,\n                        \"suggestions\": suggestions,\n                        \"thinking\": thinking,\n                        \"task_names\": task_names,\n                        \"validation_passed\": True,\n                        \"corrected\": True,\n                        \"renamed_task\": {\"from\": incorrect_task, \"to\": correct_task_name}\n                    };\n                    return;\n                }\n            }\n\n            # Handle task extraction failures\n            if validation_type == \"task_extraction\" and len(missing_tasks) > 0 {\n                user_graph = find_user_graph(here, self.username);\n                last_task = \"Start\";\n                if user_graph {\n                    last_task = user_graph?.last_task or \"Start\";\n                }\n\n                # Add each missing task to the graph\n                for missing_task in missing_tasks {\n                    here spawn update_task_graph(\n                        task_name=missing_task,\n                        previous_task=last_task,\n                        edge_label=\"then\",\n                        username=self.username\n                    );\n                    last_task = missing_task;\n                }\n\n                # Update task_names to include the newly added tasks\n                task_names.extend(missing_tasks);\n                response = f\"{response} I've also added: {', '.join(missing_tasks)}.\";\n\n                report {\n                    \"response\": response,\n                    \"emotional_state\": emotional_state.state,\n                    \"suggestions\": suggestions,\n                    \"thinking\": thinking,\n                    \"task_names\": task_names,\n                    \"validation_passed\": True,\n                    \"corrected\": True,\n                    \"added_tasks\": missing_tasks\n                };\n                return;\n            }\n\n            elif validation_type in [\"edge_labels\", \"rename_operation\", \"insert_operation\", \"reorder_operation\", \"graph_structure\"] {\n                report {\n                    \"response\": response,\n                    \"emotional_state\": emotional_state.state,\n                    \"suggestions\": suggestions,\n                    \"thinking\": thinking,\n                    \"task_names\": task_names,\n                    \"validation_passed\": False,\n                    \"validation_reason\": validation_reason\n                };\n                return;\n            }\n        }\n\n        report {\n            \"response\": response,\n            \"emotional_state\": emotional_state.state,\n            \"suggestions\": suggestions,\n            \"thinking\": thinking,\n            \"task_names\": task_names,\n            \"validation_passed\": True\n        };\n    } except Exception as e {\n        report {\"error\": \"Supervisor error\", \"details\": str(e)} ;\n    }\n}\n\n# WALKER: call_manager\nimpl call_manager.orchestrate{\n    try {\n        api_key = getenv(\"OPENAI_API_KEY\");\n        if not api_key {\n            report {\"error\": \"OPENAI_API_KEY not set\"} ;\n            return;\n        }\n\n        root spawn call_graph_agent(\n            conversation_history=self.conversation_history,\n            context_from_user=self.context_from_user,\n            username=self.username\n        );\n\n        # Read the result from manager_comm_data (stored by call_graph_agent)\n        manager_data = find_manager_comm_data(here, self.username);\n        if manager_data and manager_data.last_response {\n            graph_agent_result = {\n                \"response\": manager_data.last_response,\n                \"emotional_state\": manager_data.last_emotional_state or \"neutral\",\n                \"suggestions\": manager_data.last_suggestions or [],\n                \"thinking\": manager_data.last_thinking or {},\n                \"task_names\": manager_data.last_task_names or []\n            };\n            report graph_agent_result;\n        } else {\n            report {\n                \"error\": \"No response from graph agent\",\n                \"response\": \"I apologize, something went wrong.\"\n            };\n        }\n\n    } except Exception as e {\n        report {\n            \"error\": \"Manager processing failed\",\n            \"response\": \"I apologize, something went wrong while processing your request.\"\n        };\n    }\n}\n\ndef parse_printgraph_output(dot_output: str) -> tuple {\n    node_list = [];\n    edge_list = [];\n    node_map = {};\n\n    if not dot_output {\n        return (node_list, edge_list);\n    }\n\n    dot_output = dot_output.replace(\"&#x27;\", \"'\");\n    dot_output = dot_output.replace(\"&quot;\", '\"');\n    lines = dot_output.split(\"\\n\");\n\n    # FIRST PASS: Parse all node definitions\n    for line in lines {\n        line = line.strip();\n        if \"[label=\" in line and \"->\" not in line {\n            parts = line.split(\"[label=\");\n            if len(parts) == 2 {\n                node_id = parts[0].strip();\n                label = parts[1];\n                if \"TaskState(task_name=\" in label {\n                    start = label.find(\"task_name=\") + 11;\n                    end = label.find(\"'\", start + 1);\n                    if end > start {\n                        task_name = label[start:end];\n                        node_map[node_id] = task_name;\n                        node_list.append(task_name);\n                    }\n                }\n            }\n        }\n    }\n\n    # SECOND PASS: Parse edges (now that we have all nodes)\n    for line in lines {\n        line = line.strip();\n        if \"->\" in line and not line.startswith(\"//\") {\n            parts = line.split(\"->\");\n            if len(parts) == 2 {\n                from_id = parts[0].strip();\n                to_part = parts[1].strip();\n                to_id = \"\";\n                if \"[\" in to_part {\n                    to_id = to_part.split(\"[\")[0].strip();\n                } else {\n                    to_id = to_part.strip().rstrip(\";\");\n                }\n\n                edge_label = \"\";\n                if \"TaskFlow(label=\" in to_part {\n                    label_idx = to_part.find(\"TaskFlow(label=\");\n                    if label_idx >= 0 {\n                        rest = to_part[label_idx + 15:];\n                        if len(rest) > 1 and rest[0] == \"'\" {\n                            quote_end = rest.find(\"'\", 1);\n                            if quote_end > 1 {\n                                edge_label = rest[1:quote_end];\n                            }\n                        }\n                    }\n                }\n\n                if from_id in node_map and to_id in node_map {\n                    edge_list.append({\n                        \"from\": node_map[from_id],\n                        \"to\": node_map[to_id],\n                        \"label\": edge_label\n                    });\n                }\n            }\n        }\n    }\n\n    return (node_list, edge_list);\n}\n\ndef generate_dot_code_from_lists(node_list: list, edge_list: list) -> str {\n    if len(node_list) == 0 {\n        return \"\";\n    }\n\n    lines = [\"digraph TaskGraph {\"];\n    lines.append(\"  rankdir=TB;\");\n    lines.append(\"  node [shape=box, style=rounded, fontname=\\\"Arial\\\"];\");\n    lines.append(\"  edge [fontname=\\\"Arial\\\", fontsize=10];\");\n    lines.append(\"\");\n\n    for task_node in node_list {\n        if task_node == \"Start\" {\n            lines.append(\"  \" + task_node + \" [shape=circle, style=filled, fillcolor=\\\"#22c55e\\\", fontcolor=white];\");\n        } else {\n            lines.append(\"  \" + task_node + \" [style=\\\"rounded,filled\\\", fillcolor=\\\"#3b82f6\\\", fontcolor=white];\");\n        }\n    }\n\n    lines.append(\"\");\n\n    for conn in edge_list {\n        from_task = conn.get(\"from\", \"\");\n        to_task = conn.get(\"to\", \"\");\n        conn_label = conn.get(\"label\", \"\");\n        if conn_label {\n            lines.append(\"  \" + from_task + \" -> \" + to_task + \" [label=\\\"\" + conn_label + \"\\\"];\");\n        } else {\n            lines.append(\"  \" + from_task + \" -> \" + to_task + \";\");\n        }\n    }\n\n    lines.append(\"}\");\n    return \"\\n\".join(lines);\n}\n\ndef find_leaf_nodes(edge_list: list, node_list: list) -> list {\n    nodes_with_outgoing = {};\n    for edge in edge_list {\n        from_task = edge.get(\"from\", \"\");\n        if from_task {\n            nodes_with_outgoing[from_task] = True;\n        }\n    }\n\n    # Leaf nodes are those without outgoing edges (excluding Start)\n    leaf_nodes = [];\n    for node in node_list {\n        if node != \"Start\" and node not in nodes_with_outgoing {\n            leaf_nodes.append(node);\n        }\n    }\n\n    if len(leaf_nodes) == 0 and len(node_list) > 1 {\n        return [node_list[-1]];\n    }\n\n    return leaf_nodes;\n}\n\n\"\"\"Find user's graph or return None\"\"\"\ndef find_user_graph(root_node: node, username: str) {\n    all_graphs = [root_node-->](`?user_graph_data);\n    for graph in all_graphs {\n        if graph?.username and graph.username == username {\n            return graph;\n        }\n    }\n    return None;\n}\n\n\"\"\"Find manager comm data node or return None\"\"\"\ndef find_manager_comm_data(root_node: node, username: str) {\n    all_comm_data = [root_node-->](`?manager_comm_data);\n    for comm_data in all_comm_data {\n        if comm_data?.username and comm_data.username == username {\n            return comm_data;\n        }\n    }\n    return None;\n}\n\n\"\"\"Find Start node in graph - only direct children of user_graph\"\"\"\ndef find_start_node(graph_node: node) {\n    direct_task_nodes = [graph_node-->](`?TaskState);\n    for node in direct_task_nodes {\n        if node?.task_name and node.task_name == \"Start\" {\n            return node;\n        }\n    }\n    return None;\n}\n\n\"\"\"Get graph structure as node/edge lists and DOT code\"\"\"\ndef get_graph_structure(graph_node: node) {\n    start_node = find_start_node(graph_node);\n    node_list = [];\n    edge_list = [];\n    if start_node {\n        dot_output = printgraph(node=start_node);\n        result = parse_printgraph_output(dot_output);\n        node_list = result[0];\n        edge_list = result[1];\n    }\n    dot_code = generate_dot_code_from_lists(node_list, edge_list);\n    return (node_list, edge_list, dot_code);\n}\n\n\"\"\"Get user-specific graph structure with bounded traversal\"\"\"\ndef get_user_graph_structure(user_graph_node: node) {\n    node_list = [];\n    edge_list = [];\n\n    direct_nodes = [user_graph_node-->](`?TaskState);\n    node_map = {};\n    for node in direct_nodes {\n        if node?.task_name {\n            node_map[id(node)] = node.task_name;\n            node_list.append(node.task_name);\n        }\n    }\n\n    for from_node in direct_nodes {\n        if from_node?.task_name {\n            successors = [from_node-->](`?TaskState);\n            for to_node in successors {\n                if id(to_node) in node_map {\n                    edge_label = extract_edge_label_via_printgraph(from_node, to_node);\n                    edge_list.append({\n                        \"from\": from_node.task_name,\n                        \"to\": to_node.task_name,\n                        \"label\": edge_label\n                    });\n                }\n            }\n        }\n    }\n\n    return (node_list, edge_list);\n}\n\n# Extract edge label between two nodes using printgraph\ndef extract_edge_label_via_printgraph(from_node: node, to_node: node) -> str {\n    try {\n        dot_output = printgraph(node=from_node, depth=1);\n        if not dot_output {\n            return \"\";\n        }\n\n        dot_output = dot_output.replace(\"&#x27;\", \"'\");\n        dot_output = dot_output.replace(\"&quot;\", '\"');\n        lines = dot_output.split(\"\\n\");\n\n        to_task_name = to_node.task_name if hasattr(to_node, 'task_name') else None;\n        if not to_task_name {\n            return \"\";\n        }\n        \n        # FIRST PASS: Build node ID -> task_name map\n        node_map = {};\n        for line in lines {\n            line = line.strip();\n            if \"[label=\" in line and \"->\" not in line {\n                parts = line.split(\"[label=\");\n                if len(parts) == 2 {\n                    node_id = parts[0].strip();\n                    label = parts[1];\n                    if \"TaskState(task_name=\" in label {\n                        start = label.find(\"task_name=\") + 11;\n                        end = label.find(\"'\", start + 1);\n                        if end > start {\n                            node_map[node_id] = label[start:end];\n                        }\n                    }\n                }\n            }\n        }\n\n        target_node_id = None;\n        for node_id in node_map {\n            if node_map[node_id] == to_task_name {\n                target_node_id = node_id;\n                break;\n            }\n        }\n\n        if not target_node_id {\n            return \"\";\n        }\n        \n        # SECOND PASS: Find edge to target and extract TaskFlow label\n        for line in lines {\n            line = line.strip();\n            if \"->\" in line and not line.startswith(\"//\") {\n                parts = line.split(\"->\");\n                if len(parts) == 2 {\n                    to_part = parts[1].strip();\n                    to_id = to_part.split(\"[\")[0].strip() if \"[\" in to_part else to_part.strip().rstrip(\";\");\n\n                    if to_id == target_node_id and \"TaskFlow(label=\" in to_part {\n                        label_idx = to_part.find(\"TaskFlow(label=\");\n                        rest = to_part[label_idx + 15:];\n                        if len(rest) > 1 and rest[0] == \"'\" {\n                            quote_end = rest.find(\"'\", 1);\n                            if quote_end > 1 {\n                                return rest[1:quote_end];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    } except Exception as e {\n        # Silently fail and return empty label\n        return \"\";\n    }\n\n    return \"\";\n}\n\nimpl validate_graph_output.validate {\n    manager_data = find_manager_comm_data(here, self.username);\n    if not manager_data {\n        manager_data = here ++> manager_comm_data(username=self.username);\n    }\n\n    intent_analysis = self.intent_analysis or {};\n    extracted_tasks = self.extracted_tasks or [];\n    before_nodes = self.before_nodes or [];\n    before_edges = self.before_edges or [];\n    after_nodes = self.after_nodes or [];\n    after_edges = self.after_edges or [];\n    user_message = self.context_from_user;\n\n    conversation_context = intent_analysis.get(\"conversation_context\", {});\n    correction_type = conversation_context.get(\"correction_type\", \"\");\n    referring_to_task = conversation_context.get(\"referring_to_task\", \"\");\n    tasks_to_move = conversation_context.get(\"tasks_to_move\", []);\n\n    manager_data.validation_passed = True;\n    manager_data.validation_reason = \"\";\n    manager_data.validation_type = \"\";\n    manager_data.correction_needed = False;\n    manager_data.missing_tasks = [];\n    manager_data.incorrect_task = \"\";\n    manager_data.correct_task_name = \"\";\n\n    # Route to appropriate validation based on operation type\n    if correction_type == \"rename\" {\n        old_task = None;\n        new_task = None;\n\n        for node in before_nodes {\n            if node not in after_nodes and node != \"Start\" {\n                old_task = node;\n                break;\n            }\n        }\n\n        for node in after_nodes {\n            if node not in before_nodes {\n                new_task = node;\n                break;\n            }\n        }\n\n        if not old_task or not new_task {\n            return;\n        }\n\n        rename_validation = validate_rename_operation(\n            user_message=user_message,\n            old_task=old_task,\n            new_task=new_task,\n            before_nodes=before_nodes,\n            after_nodes=after_nodes,\n            before_edges=before_edges,\n            after_edges=after_edges\n        );\n\n        if not rename_validation.is_valid {\n            manager_data.validation_passed = False;\n            manager_data.validation_reason = rename_validation.reason;\n            manager_data.validation_type = \"rename_operation\";\n        }\n    }\n    elif correction_type in [\"insert_before\", \"insert_after\", \"insert_first\"] {\n        insert_validation = validate_insert_operation(\n            user_message=user_message,\n            operation_type=correction_type,\n            referring_to_task=referring_to_task,\n            new_tasks=extracted_tasks,\n            before_edges=before_edges,\n            after_edges=after_edges\n        );\n\n        if not insert_validation.is_valid {\n            manager_data.validation_passed = False;\n            manager_data.validation_reason = insert_validation.reason;\n            manager_data.validation_type = \"insert_operation\";\n        }\n    }\n    elif correction_type == \"reorder\" or len(tasks_to_move) > 0 {\n        reorder_tasks = tasks_to_move if len(tasks_to_move) > 0 else extracted_tasks;\n\n        reorder_validation = validate_reorder_operation(\n            user_message=user_message,\n            tasks_to_move=reorder_tasks,\n            before_edges=before_edges,\n            after_edges=after_edges\n        );\n\n        if not reorder_validation.is_valid {\n            manager_data.validation_passed = False;\n            manager_data.validation_reason = reorder_validation.reason;\n            manager_data.validation_type = \"reorder_operation\";\n        }\n    }\n    else {\n        conversation_context = intent_analysis.get(\"conversation_context\", {});\n        intent_str = str(conversation_context.get(\"intent\", \"\")) if conversation_context.get(\"intent\") else \"\";\n\n        if \"ASK_QUESTION\" in intent_str or \"THINK_ALOUD\" in intent_str {\n            return;\n        }\n\n        # Validation 1: Task Extraction (pass before_nodes for rename detection)\n        task_validation = validate_task_extraction(\n            user_message=user_message,\n            extracted_tasks=extracted_tasks,\n            existing_nodes=before_nodes\n        );\n\n        if not task_validation.is_valid {\n            if task_validation.incorrect_task and len(task_validation.incorrect_task) > 0 {\n                manager_data.validation_passed = False;\n                manager_data.validation_reason = task_validation.reason;\n                manager_data.validation_type = \"task_rename\";\n                manager_data.incorrect_task = task_validation.incorrect_task;\n                manager_data.correct_task_name = task_validation.correct_task_name;\n                manager_data.correction_needed = True;\n                return;\n            }\n\n            # Standard missing tasks case\n            manager_data.validation_passed = False;\n            manager_data.validation_reason = task_validation.reason;\n            manager_data.correction_needed = True;\n            manager_data.missing_tasks = task_validation.missing_tasks;\n            manager_data.validation_type = \"task_extraction\";\n            return;\n        }\n\n        # Validation 2: Edge Label Validation\n        if len(after_edges) > 0 {\n            edge_label_validation = validate_edge_labels(\n                user_message=user_message,\n                new_edges=after_edges\n            );\n\n            if not edge_label_validation.is_valid {\n                manager_data.validation_passed = False;\n                manager_data.validation_reason = edge_label_validation.reason;\n                manager_data.validation_type = \"edge_labels\";\n                return;\n            }\n        }\n\n        # Validation 3: Graph Structure Validation\n        new_task_edges = [];\n        for edge in after_edges {\n            if edge.get(\"to\", \"\") in extracted_tasks {\n                new_task_edges.append(edge);\n            }\n        }\n\n        graph_validation = validate_graph_structure(\n            user_message=user_message,\n            graph_nodes=extracted_tasks,\n            graph_edges=new_task_edges\n        );\n\n        if not graph_validation.is_valid {\n            manager_data.validation_passed = False;\n            manager_data.validation_reason = graph_validation.reason;\n            manager_data.validation_type = \"graph_structure\";\n        }\n    }\n}",
    "service/mainAppService.jac": "import from os { getenv }\nimport from urllib.request { Request, urlopen }\nimport from urllib.error { URLError, HTTPError }\nimport from json { loads, dumps }\nimport from dotenv { load_dotenv }\nimport from semantics.semantics {\n    EmotionalState,\n    ConversationIntent,\n    ConversationContext,\n    ConnectionType,\n    TaskRelationship,\n    IntentAnalysis,\n    ExtractedTasks,\n    AttachmentPointAnalysis,\n    ConvergenceIntent,\n    ThinkingSummary,\n    TaskValidationResult,\n    GraphValidationResult,\n    RenameValidationResult,\n    InsertValidationResult,\n    ReorderValidationResult,\n    EdgeLabelValidationResult,\n    detect_emotional_state,\n    analyze_conversation_intent,\n    extract_raw_task_names,\n    determine_attachment_points,\n    detect_convergence_intent,\n    build_task_relationships,\n    generate_friendly_response,\n    generate_next_suggestions,\n    generate_thinking_summary,\n    validate_task_extraction,\n    validate_graph_structure,\n    validate_rename_operation,\n    validate_insert_operation,\n    validate_reorder_operation,\n    validate_edge_labels\n}\n\nnode TaskState {\n    has task_name: str;\n    has created_at: str = \"\";\n}\n\nedge TaskFlow {\n    has label: str = \"\";  # \"then\", \"if yes\", \"option 1\", etc.\n}\n\nnode user_graph_data {\n    has username: str = \"anonymous\";\n    has last_task: str = \"Start\";\n    has saved_routines: dict = {};\n}\n\nnode manager_comm_data {\n    has username: str = \"anonymous\";\n    has last_response: str = \"\";\n    has last_suggestions: list = [];\n    has last_thinking: dict = {};\n    has last_task_names: list = [];\n    has last_emotional_state: str = \"neutral\";\n    has validation_passed: bool = True;\n    has validation_reason: str = \"\";\n    has validation_type: str = \"\";\n    has correction_needed: bool = False;\n    has missing_tasks: list[str] = [];\n    has incorrect_task: str = \"\";      # Existing task with wrong name that should be renamed\n    has correct_task_name: str = \"\";    # What the task should be renamed to\n}\n\nnode user_routines {\n    has username: str = \"anonymous\";\n    has routines: dict = {};\n}\n\nwith entry {\n    load_dotenv();\n}\n\nwalker :pub get_session_token {\n    can fetch with `root entry;\n}\n\nwalker :pub init_user_graph {\n    can initialize with `root entry;\n}\n\nwalker :pub update_task_graph {\n    has task_name: str;\n    has previous_task: str = \"Start\";\n    has edge_label: str = \"\";\n    has username: str = \"anonymous\";\n\n    can navigate_to_graph with `root entry;\n    can update_graph with user_graph_data entry;\n}\n\nwalker :pub get_task_graph {\n    has username: str = \"anonymous\";\n\n    can navigate_to_graph with `root entry;\n    can get_graph with user_graph_data entry;\n}\n\nwalker :pub clear_graph {\n    has username: str = \"anonymous\";\n\n    can navigate_to_graph with `root entry;\n    can clear_data with user_graph_data entry;\n}\n\nwalker :pub save_routine {\n    has routine_name: str = \"daily_routine\";\n    has username: str = \"anonymous\";\n\n    can navigate_to_graph with `root entry;\n    can save_routine_data with user_graph_data entry;\n}\n\nwalker :pub load_past_routines {\n    has username: str = \"anonymous\";\n\n    can navigate_to_routines with `root entry;\n    can load_routines with user_routines entry;\n}\n\nwalker :pub reset_session {\n    has username: str = \"anonymous\";\n\n    can navigate_to_graph with `root entry;\n    can reset_graph with user_graph_data entry;\n}\n\nwalker :pub rebuild_graph {\n    has new_nodes: list;\n    has new_edges: list;\n    has username: str = \"anonymous\";\n\n    can navigate_to_graph with `root entry;\n    can rebuild with user_graph_data entry;\n}\n\nwalker :pub rename_task {\n    has old_name: str;\n    has new_name: str;\n    has username: str = \"anonymous\";\n\n    can navigate_to_graph with `root entry;\n    can rename with user_graph_data entry;\n}\n\nwalker :pub call_graph_agent {\n    has conversation_history: list;\n    has context_from_user: str;\n    has username: str = \"anonymous\";\n\n    can call with `root entry;\n}\n\nwalker :pub call_manager {\n    has conversation_history: list;\n    has context_from_user: str;\n    has username: str = \"anonymous\";\n\n    can orchestrate with `root entry;\n}\n\nwalker :pub validate_graph_output {\n    has context_from_user: str;\n    has intent_analysis: dict;\n    has extracted_tasks: list;\n    has before_nodes: list;\n    has before_edges: list;\n    has after_nodes: list;\n    has after_edges: list;\n    has username: str = \"anonymous\";\n\n    can validate with `root entry;\n}\n",
    "components/ControlBar.cl.jac": "# ControlBar Component\n# Bottom control bar with connection, PTT, and audio controls\n\nimport from ..utils.mergeCls { cn }\n\ndef:pub ControlBar(\n    sessionStatus: str,\n    isPTTActive: bool,\n    setIsPTTActive: any,\n    isPTTUserSpeaking: bool,\n    onTalkDown: any,\n    onTalkUp: any,\n    isAudioPlaybackEnabled: bool,\n    setIsAudioPlaybackEnabled: any,\n    isMicMuted: bool,\n    onToggleMicMute: any,\n    onSaveAndRestart: any\n) -> any {\n    # Computed values\n    isConnected = sessionStatus == \"CONNECTED\";\n    \n    micBtnClass = cn(\n        \"text-white px-4 py-2 rounded-md border-none transition-all flex items-center justify-center min-w-12\",\n        (\"cursor-not-allowed bg-text-secondary\" if not isConnected else (\n            \"cursor-pointer\" + (\" bg-error\" if isMicMuted else \" bg-black hover:opacity-90\")\n        ))\n    );\n    \n    micBtnTitle = \"Mute microphone\" if not isMicMuted else \"Unmute microphone\";\n\n    # Mic icon SVG - unmuted\n    micIconUnmuted = <svg\n        width=\"20\"\n        height=\"20\"\n        viewBox=\"0 0 24 24\"\n        fill=\"none\"\n        stroke=\"currentColor\"\n        strokeWidth=\"2\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n        className=\"block\"\n    >\n        <path d=\"M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z\" />\n        <path d=\"M19 10v2a7 7 0 0 1-14 0v-2\" />\n        <line x1=\"12\" x2=\"12\" y1=\"19\" y2=\"22\" />\n        <line x1=\"8\" x2=\"16\" y1=\"22\" y2=\"22\" />\n    </svg>;\n\n    # Mic icon SVG - muted\n    micIconMuted = <svg\n        width=\"20\"\n        height=\"20\"\n        viewBox=\"0 0 24 24\"\n        fill=\"none\"\n        stroke=\"currentColor\"\n        strokeWidth=\"2\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n        className=\"block\"\n    >\n        <path d=\"M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z\" />\n        <path d=\"M19 10v2a7 7 0 0 1-14 0v-2\" />\n        <line x1=\"12\" x2=\"12\" y1=\"19\" y2=\"22\" />\n        <line x1=\"2\" x2=\"22\" y1=\"2\" y2=\"22\" />\n    </svg>;\n\n    # Choose the correct icon based on mute state\n    micIcon = micIconMuted if isMicMuted else micIconUnmuted;\n    \n    # Talk button class\n    talkBtnClass = cn(\n        \"px-4 py-1 border-none rounded-md transition-all\",\n        (\"cursor-not-allowed text-text-secondary bg-gray-200\" if not isPTTActive else (\n            \"cursor-pointer text-black\" + (\" bg-gray-300\" if isPTTUserSpeaking else \" bg-gray-200 hover:bg-gray-300\")\n        ))\n    );\n    \n    # Save button class\n    saveBtnClass = cn(\n        \"text-white text-sm px-4 py-2 rounded-md border-none font-semibold transition-all\",\n        (\"cursor-not-allowed bg-text-secondary\" if not isConnected else \n         \"cursor-pointer bg-success hover:opacity-90\")\n    );\n\n    return <div className=\"p-4 flex flex-row items-center justify-center gap-8 border-t border-border bg-surface\">\n        <button\n            onClick={onToggleMicMute}\n            disabled={not isConnected}\n            title={micBtnTitle}\n            className={micBtnClass}\n        >\n            {micIcon}\n        </button>\n\n        <div className=\"flex flex-row items-center gap-2\">\n            <input\n                id=\"push-to-talk\"\n                type=\"checkbox\"\n                checked={isPTTActive}\n                onChange={lambda e: any -> None { setIsPTTActive(e.target.checked); }}\n                disabled={not isConnected}\n                className=\"w-4 h-4 accent-primary\"\n            />\n            <label htmlFor=\"push-to-talk\" className=\"flex items-center cursor-pointer text-text-primary\">\n                {\"Push to talk\"}\n            </label>\n            <button\n                onMouseDown={onTalkDown}\n                onMouseUp={onTalkUp}\n                onTouchStart={onTalkDown}\n                onTouchEnd={onTalkUp}\n                disabled={not isPTTActive}\n                className={talkBtnClass}\n            >\n                {\"Talk\"}\n            </button>\n        </div>\n        \n        <div className=\"flex flex-row items-center gap-1\">\n            <input\n                id=\"audio-playback\"\n                type=\"checkbox\"\n                checked={isAudioPlaybackEnabled}\n                onChange={lambda e: any -> None { setIsAudioPlaybackEnabled(e.target.checked); }}\n                disabled={not isConnected}\n                className=\"w-4 h-4 accent-primary\"\n            />\n            <label htmlFor=\"audio-playback\" className=\"flex items-center cursor-pointer text-text-primary\">\n                {\"Audio playback\"}\n            </label>\n        </div>\n        \n        <button\n            onClick={onSaveAndRestart}\n            disabled={not isConnected}\n            className={saveBtnClass}\n        >\n            {\"Save & Restart\"}\n        </button>\n    </div>;\n}",
    "components/SuggestionChips.cl.jac": "# SuggestionChips Component\n# Displays clickable suggestion chips for quick responses\n\nimport from ..utils.mergeCls { cn }\n\ndef:pub SuggestionChips(\n    suggestions: list,\n    onSelectSuggestion: any\n) -> any {\n    \n    # Don't render if no suggestions\n    if not suggestions or suggestions.length == 0 {\n        return None;\n    }\n    \n    return <div className=\"px-4 pb-2 flex gap-2 items-center flex-wrap\">\n        <span className=\"text-xs text-text-secondary font-medium\">\n            {\"Quick replies:\"}\n        </span>\n        {suggestions.map(lambda suggestion: any, idx: int -> any {\n            return <button\n                key={idx}\n                onClick={lambda -> None { onSelectSuggestion(suggestion); }}\n                className=\"px-3 py-1.5 bg-surface-elevated text-text-primary text-sm rounded-full border border-border cursor-pointer transition-all hover:bg-primary hover:text-primary-foreground hover:border-primary hover:-translate-y-0.5 active:translate-y-0 font-medium\"\n            >\n                {suggestion}\n            </button>;\n        })}\n    </div>;\n}\n",
    "components/Header.cl.jac": "# Header Component\n# Application header with title and username display\n\nimport from \"@jac/runtime\" { jacLogout, useNavigate }\nimport from ..utils.mergeCls { cn }\n\ndef:pub Header() -> any {\n    navigate = useNavigate();\n    has username: str = \"User\";\n\n    def handleLogout(e: any) -> None {\n        e.preventDefault();\n        jacLogout();\n        navigate(\"/login\");\n    }\n\n    return <header className=\"px-5 py-4 text-lg font-semibold flex justify-between items-center border-b border-border bg-surface\">\n        <div className=\"flex items-center gap-2\">\n            <span className=\"text-2xl\">{\"\ud83c\udf99\ufe0f\"}</span>\n            <span className=\"text-text-primary\">{\"Algo - Your Personal AI Assistant\"}</span>\n        </div>\n        <div className=\"flex items-center gap-6\">\n            <span className=\"text-sm text-text-secondary font-medium\">\n                {f\"\ud83d\udc64 {username}\"}\n            </span>\n            <button\n                onClick={handleLogout}\n                className=\"px-4 py-2 text-sm font-medium text-primary-foreground bg-gradient-to-br from-primary to-secondary border-none rounded-md cursor-pointer transition-all shadow-md hover:opacity-90 hover:-translate-y-0.5 active:translate-y-0\"\n            >\n                {\"Logout\"}\n            </button>\n        </div>\n    </header>;\n}\n",
    "components/Layout.cl.jac": "# Layout Component\n# Simple shared layout wrapper for all pages\n\nimport from ..hooks.useHead { useHead, DEFAULT_META }\n\ndef:pub Layout(\n    children: any,\n    meta: any = None\n) -> any {\n    activeMeta = meta or DEFAULT_META;\n    \n    # Merge with defaults\n    finalMeta = {\n        \"title\": activeMeta.title or DEFAULT_META.title,\n        \"description\": activeMeta.description or DEFAULT_META.description,\n        \"favicon\": activeMeta.favicon or DEFAULT_META.favicon,\n        \"themeColor\": activeMeta.themeColor or DEFAULT_META.themeColor,\n        \"ogImage\": activeMeta.ogImage or DEFAULT_META.ogImage\n    };\n    \n    # Apply head configuration\n    useHead(finalMeta);\n    \n    return <div className=\"min-h-screen bg-background text-text-primary font-sans\">\n        {children}\n    </div>;\n}",
    "components/TranscriptItem.cl.jac": "# TranscriptItem Component\n# Renders a single transcript message with role-based styling\n\nimport from ..utils.mergeCls { cn }\n\ndef:pub TranscriptItem(item: any, showThinking: bool = True) -> any {\n    role = item.role;\n    content = item.content;\n    thinking = item.thinking;\n\n    isUser = role == \"user\";\n    isSystem = role == \"system\" or role == \"tool\";\n    isAssistant = role == \"assistant\";\n\n    # State for expandable thinking details\n    # Using new has syntax for reactive state\n    has showDetails: bool = False;\n    \n    # Container alignment based on role\n    containerClass = cn(\n        \"flex flex-col gap-1\",\n        (\"items-end\" if isUser else \"items-start\")\n    );\n    \n    # Message bubble styling based on role\n    bubbleClass = cn(\n        \"max-w-lg px-3 py-2 rounded-xl\",\n        ((\"bg-secondary text-secondary-foreground\") if isUser else (\n            (\"bg-warning/20 text-text-primary\") if isSystem else \n            \"bg-surface-hover text-text-primary\"\n        ))\n    );\n    \n    # Role label styling\n    labelClass = cn(\n        \"text-xs mb-1 uppercase font-semibold\",\n        (\"text-text-secondary/70\" if isUser else \"text-text-secondary\")\n    );\n    \n    # Thinking bubble styling\n    thinkingBubbleClass = \"text-xs italic text-text-secondary bg-surface/50 px-2 py-1 rounded-lg max-w-lg\";\n    \n    # Check if thinking has any non-empty values\n    hasThinking = False;\n    if isAssistant and thinking and showThinking {\n        emotional = thinking.emotional or \"\";\n        intent = thinking.intent or \"\";\n        tasks = thinking.tasks or \"\";\n        pattern = thinking.pattern or \"\";\n        hasThinking = emotional != \"\" or intent != \"\" or tasks != \"\" or pattern != \"\";\n        console.log(\"hasThinking:\", hasThinking);\n    }\n    \n    return <div className={containerClass}>\n        {hasThinking and (\n            <div className=\"flex flex-col gap-1 max-w-lg w-full\">\n                {thinking.emotional and thinking.emotional != \"\" and (\n                    <div className={thinkingBubbleClass}>\ud83d\udcad {thinking.emotional}</div>\n                )}\n                {thinking.intent and thinking.intent != \"\" and (\n                    <div className={thinkingBubbleClass}>\ud83d\udcad {thinking.intent}</div>\n                )}\n                {thinking.tasks and thinking.tasks != \"\" and (\n                    <div className={thinkingBubbleClass}>\ud83d\udcad {thinking.tasks}</div>\n                )}\n                {thinking.pattern and thinking.pattern != \"\" and (\n                    <div className={thinkingBubbleClass}>\ud83d\udcad {thinking.pattern}</div>\n                )}\n            </div>\n        )}\n        \n        <div className={bubbleClass}>\n            <div className={labelClass}>\n                {role}\n            </div>\n            <div className=\"text-sm leading-relaxed\">{content}</div>\n        </div>\n    </div>;\n}\n",
    "components/GraphViewer.cl.jac": "# GraphViewer Component - Renders GraphViz DOT code\nimport from react { useRef }\nimport from \"@hpcc-js/wasm/graphviz\" { Graphviz }\nimport from ..utils.mergeCls { cn }\n\ndef:pub GraphViewer(dotCode: str) -> any {\n    # Reactive state using has variables\n    has svgContent: str = \"\";\n    has isLoading: bool = True;\n    has renderKey: int = 0;\n\n    prevDotCodeRef = useRef(\"\");\n\n    # Render DOT code to SVG whenever it changes\n    # Using new can with [dep] entry syntax\n    async can with [dotCode] entry {\n        console.log(\"GraphViewer effect triggered\");\n        console.log(\"Current dotCode:\", dotCode);\n        console.log(\"Previous dotCode:\", prevDotCodeRef.current);\n\n        # Check if dotCode actually changed\n        if dotCode == prevDotCodeRef.current {\n            console.log(\"DotCode unchanged, skipping render\");\n            return;\n        }\n\n        prevDotCodeRef.current = dotCode;\n\n        if dotCode and dotCode.length > 0 {\n            try {\n                console.log(\"Rendering new graph...\");\n                isLoading = True;\n                graphviz = await Graphviz.load();\n                svg = graphviz.dot(dotCode);\n                console.log(\"Graph rendered, SVG length:\", svg.length);\n                svgContent = svg;\n                renderKey = renderKey + 1;\n                isLoading = False;\n            } except Exception as e {\n                console.error(\"Error rendering graph:\", e);\n                isLoading = False;\n            }\n        } else {\n            console.log(\"No dotCode to render\");\n            isLoading = False;\n        }\n    }\n    \n    # Empty state\n    if not dotCode or dotCode.length == 0 {\n        return <div className=\"flex items-center justify-center h-full text-text-secondary text-sm text-center p-8\">\n            <div>\n                <div className=\"text-4xl mb-2\">{\"\ud83c\udf33\"}</div>\n                <div>{\"Your task graph will appear here\"}</div>\n            </div>\n        </div>;\n    }\n    \n    # Loading state\n    if isLoading {\n        return <div className=\"flex items-center justify-center h-full text-text-secondary\">\n            <div className=\"flex items-center gap-2\">\n                <div className=\"w-5 h-5 border-2 border-text-secondary/30 border-t-text-secondary rounded-full animate-spin\" />\n                <span>{\"Loading graph...\"}</span>\n            </div>\n        </div>;\n    }\n    \n    # Rendered graph\n    return <div \n        key={renderKey}\n        className=\"p-8 h-full overflow-y-auto bg-surface-hover flex justify-center items-start\"\n    >\n        <div dangerouslySetInnerHTML={{\"__html\": svgContent}}></div>\n    </div>;\n}",
    "components/MessageInput.cl.jac": "# MessageInput Component\n# Text input field with send button, voice call button, and suggestion chips\n\nimport from ..utils.mergeCls { cn }\nimport from .SuggestionChips { SuggestionChips }\n\ndef:pub MessageInput(\n    userText: str,\n    setUserText: any,\n    onSend: any,\n    suggestions: list = [],\n    onSelectSuggestion: any = None,\n    sessionStatus: str = \"DISCONNECTED\",\n    onToggleConnection: any = None\n) -> any {\n    \n    # Compute connection state\n    isConnected = sessionStatus == \"CONNECTED\";\n    isConnecting = sessionStatus == \"CONNECTING\";\n    \n    # Voice button styling\n    voiceBtnClass = cn(\n        \"w-12 h-12 rounded-full border-none flex items-center justify-center transition-all\",\n        (\n            \"bg-error text-white cursor-pointer hover:opacity-90\" if isConnected else (\n                \"bg-gray-300 text-gray-500 cursor-not-allowed opacity-70\" if isConnecting else \n                \"bg-success text-white cursor-pointer hover:opacity-90\"\n            )\n        )\n    );\n    \n    # Voice call icon SVG - for connecting\n    voiceConnectIcon = <svg\n        width=\"20\"\n        height=\"20\"\n        viewBox=\"0 0 24 24\"\n        fill=\"none\"\n        stroke=\"currentColor\"\n        strokeWidth=\"2\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n    >\n        <path d=\"M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z\" />\n    </svg>;\n    \n    # Voice disconnect icon SVG - phone with X/hang up\n    voiceDisconnectIcon = <svg\n        width=\"20\"\n        height=\"20\"\n        viewBox=\"0 0 24 24\"\n        fill=\"none\"\n        stroke=\"currentColor\"\n        strokeWidth=\"2\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n    >\n        <path d=\"M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91\" />\n        <line x1=\"22\" x2=\"2\" y1=\"2\" y2=\"22\" />\n    </svg>;\n    \n    # Choose icon based on connection state\n    voiceIcon = voiceDisconnectIcon if isConnected else voiceConnectIcon;\n    \n    return <div className=\"border-t border-border bg-surface\">\n        <SuggestionChips \n            suggestions={suggestions}\n            onSelectSuggestion={onSelectSuggestion}\n        />\n        \n        <div className=\"p-4 flex gap-2\">\n            <input\n                type=\"text\"\n                value={userText}\n                onChange={lambda e: any -> None { setUserText(e.target.value); }}\n                onKeyPress={lambda e: any -> None { if e.key == \"Enter\" { onSend(); } }}\n                placeholder=\"Click the \ud83d\udcde for the best experience or type your message here...\"\n                className=\"flex-1 px-4 py-3 border border-border rounded-lg text-base bg-surface text-text-primary placeholder:text-text-secondary focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary transition-all\"\n            />\n            <button\n                onClick={onToggleConnection}\n                disabled={isConnecting}\n                title={(\"Disconnect voice\" if isConnected else (\"Connecting...\" if isConnecting else \"Connect voice\"))}\n                className={voiceBtnClass}\n            >\n                {voiceIcon}\n            </button>\n            <button\n                onClick={onSend}\n                className=\"px-6 py-3 bg-secondary text-secondary-foreground border-none rounded-lg cursor-pointer font-medium transition-all hover:opacity-90 hover:-translate-y-0.5 active:translate-y-0\"\n            >\n                {\"Send\"}\n            </button>\n        </div>\n    </div>;\n}",
    "assets/favicon.ico": "base64:AAABAAMAEBAAAAEAIABoBAAANgAAACAgAAABACAAKBEAAJ4EAAAwMAAAAQAgAGgmAADGFQAAKAAAABAAAAAgAAAAAQAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoqz6NGl++3lie/yaY4D8mm6L+3mkt/U1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACSmPovWGj8xD1T/v87Vv//PVz//z9i//9Aaf//RXH+/2SL/sSYuPovAAAAAAAAAAAAAAAAAAAAAAAAAAB+hPxNQk/+9jdJ//85UP//O1b//z1c//8/Yv//QGn//0Jv//9Edf//UoT+9omt+E4AAAAAAAAAAAAAAACNkvovQUn+9mVw//91gf//PVP//ztW//89XP//P2L//0Bp//9Fcv//fJ7//3Gb//9Uiv72nbj6LwAAAAAAAAAAVVr8xDQ9//9QXP//+/z//+7w//+frf//PVz//z9i//+dsf//7fH///v8//9ejf//SIL//2ic/sQAAAAAnZ31NDY6/v80Pf//NUP//7W8/////////v7//2qC//9mgv///v7///////+2yv//Rnz//0iC//9Niv7/rMT6NGNl+3kyNv//ND3//zVD//9XZv///f3////////I0v//nq/////////7/P//XYj//0Z8//9Igv//Soj//3ip/XlYWP2ZMjb//zQ9//81Q///N0n//73E/////////v7//5Oo///+/v//t8j//0R1//9GfP//SIL//0qI//9tovyaWFr9mTI2//80Pf//NUP//zdJ//9ecP///v7////////m6///xND//1yD//9Edf//Rnz//0iC//9KiP//baL8mmVl+3kyNv//ND3//zVD//83Sf//OVD//8TL/////////////7HB//9Cb///RHX//0Z8//9Igv//Soj//3ip/Xmbm/ozNjr+/zQ9//81Q///N0n//zlQ//9mev///v7///z8//9bf///Qm///0R1//9GfP//SIL//02K/v+nxPU0AAAAAFVa/MQ0Pf//NUP//zdJ//85UP//O1b//8vT//+3xf//QGn//0Jv//9Edf//Rnz//0iC//9om/zEAAAAAAAAAACQlvkuQEn+9jVD//83Sf//OVD//ztW//9jfP//WHf//0Bp//9Cb///RHX//0Z8//9Tif72m7z/LgAAAAAAAAAAAAAAAICG/ExCT/71N0n//zlQ//87Vv//PVz//z9i//9Aaf//Qm///0R1//9Rg/72iKz4TQAAAAAAAAAAAAAAAAAAAAAAAAAAkJv5Llln/sM9U/7/O1b//z1c//8/Yv//QGn//0Vy/v9ji/zEm7f5LgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAo636MmyC/Xhie/yZZID8mXCN+3mltPUzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAACAAAABAAAAAAQAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADb2+0O6ur6MO7u8jvu7vI76u/6MNvb7Q4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANLW9z6OnPqVcYT72WB3/f1KZv3/QWH+/0Jj/v9Mb/3/ZIP9/XaT+9mSqviW1t73PgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL/G+Eh4hPvMR1v9/zpR//87Vf//PFj//z1b//8+Xv//P2H//z9k//9AaP//QWv//0Ju//9Qev3/f5/7zcTO9UkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOPj8RKMlPurRVX+/jhL//85T///OlH//ztV//88WP//PVv//z5e//8/Yf//P2T//0Bo//9Ba///Qm7//0Nx//9EdP//UoH+/pOw+azj8f8SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADS0vIobnf83TZF/v83SP//OEv//zlP//86Uf//O1X//zxY//89W///Pl7//z9h//8/ZP//QGj//0Fr//9Cbv//Q3H//0R0//9Fd///Rnr+/3qg/N3S3/koAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0dH4J2Nr/Og1Qv//NkX//zdI//84S///OU///zpR//87Vf//PFj//z1b//8+Xv//P2H//z9k//9AaP//QWv//0Ju//9Dcf//RHT//0V3//9Gev//R37//3Gb/OnS3/IoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOPj8RJscvzdNT7//zVC//9EUv//N0j//zhL//85T///OlH//ztV//88WP//PVv//z5e//8/Yf//P2T//0Bo//9Ba///Qm7//0Nx//9EdP//RXf//1CC//9Hfv//SIH//3uk+t7j4/ESAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiI37qjQ8/v81Pv//NUL//+jq///X2///jpn//0ld//86Uf//O1X//zxY//89W///Pl7//z9h//8/ZP//QGj//0Fr//9Cbv//UHv//5Gt///X4v//6e///0d+//9Igf//SYT+/5W2+asAAAAAAAAAAAAAAAAAAAAAAAAAAL299UlBR/7+NDz//zU+//81Qv//lp7/////////////+vv//8HI//94iv//QFz//z1b//8+Xv//P2H//z9k//9Dav//eZb//8DO///5+v////////////+duf//R37//0iB//9JhP//VpD+/sTZ+EkAAAAAAAAAAAAAAAAAAAAAdHb6zTM4//80PP//NT7//zVC//9CUP//8vP////////////////////////Gz///PVv//z5e//8/Yf//P2T//7nH////////////////////////8PT//0+B//9Hfv//SIH//0mE//9Kh///hK77zQAAAAAAAAAAAAAAANDQ9jxAQ/3/Mzj//zQ8//81Pv//NUL//zZF//+dpf////////////////////////7+//9nf///Pl7//z9h//9eff///P3///////////////////////+duP//Rnr//0d+//9Igf//SYT//0qH//9Xkv3/1eLyPQAAAAAAAAAAiYv4lTI1//8zOP//NDz//zU+//81Qv//NkX//0ZW///19v///////////////////////8fQ//8+Xv//P2H//73J////////////////////////8PT//05+//9Gev//R37//0iB//9JhP//Sof//0uK//+Yu/qVAAAAAAAAAABqbfraMjX//zM4//80PP//NT7//zVC//82Rf//N0j//6Wt/////////////////////////v7//2aA//9Iaf///f3///////////////////////+et///RXf//0Z6//9Hfv//SIH//0mE//9Kh///S4r//36s+9oAAAAA29v/Dlha/P0yNf//Mzj//zQ8//81Pv//NUL//zZF//83SP//S13///j5////////////////////////wMv//0Bi///09v//////////////////8fT//057//9Fd///Rnr//0d+//9Igf//SYT//0qH//9Liv//baH9/d3d7g/k5PQvQEH9/zI1//8zOP//NDz//zU+//81Qv//NkX//zdI//84S///q7T////////////////////////8/f//XXr//73K//////////////////+etv//RHT//0V3//9Gev//R37//0iB//9JhP//Sof//0uK//9Ylf3/5Or0MO3t9jo1Nv7/MjX//zM4//80PP//NT7//zVC//82Rf//N0j//zhL//9QY///+vv////////////////////////M1v//aYb///3+////////8vX//055//9EdP//RXf//0Z6//9Hfv//SIH//0mE//9Kh///S4r//06P/v/u8vY77e32OjU2/v8yNf//Mzj//zQ8//81Pv//NUL//zZF//83SP//OEv//zlP//+yu/////////////////////////////+fsf//scH///////+ftf//Q3H//0R0//9Fd///Rnr//0d+//9Igf//SYT//0qH//9Liv//To/+/+7y9jvk5PQvQEL9/zI1//8zOP//NDz//zU+//81Qv//NkX//zdI//84S///OU///1Zq///8/P////////////////////////7+//+fsv//w9D//012//9Dcf//RHT//0V3//9Gev//R37//0iB//9JhP//Sof//0uK//9Ylf3/5Or0MNvb/w5ZWvz9MjX//zM4//80PP//NT7//zVC//82Rf//N0j//zhL//85T///OlH//7nC//////////////////////////////////+Fn///Qm7//0Nx//9EdP//RXf//0Z6//9Hfv//SIH//0mE//9Kh///S4r//22i/f3d7v8PAAAAAGxt+9kyNf//Mzj//zQ8//81Pv//NUL//zZF//83SP//OEv//zlP//86Uf//XHH///39////////////////////////8/X//050//9Cbv//Q3H//0R0//9Fd///Rnr//0d+//9Igf//SYT//0qH//9Liv//faz72gAAAAAAAAAAh4n6kzI1//8zOP//NDz//zU+//81Qv//NkX//zdI//84S///OU///zpR//87Vf//wMn///////////////////////+gtP//QWv//0Ju//9Dcf//RHT//0V3//9Gev//R37//0iB//9JhP//Sof//0uK//+WuviUAAAAAAAAAADPz/I7QEP9/zM4//80PP//NT7//zVC//82Rf//N0j//zhL//85T///OlH//ztV//9ieP///v7/////////////8/X//01y//9Ba///Qm7//0Nx//9EdP//RXf//0Z6//9Hfv//SIH//0mE//9Kh///V5L9/9Td8jwAAAAAAAAAAAAAAAB0d/vMMzj//zQ8//81Pv//NUL//zZF//83SP//OEv//zlP//86Uf//O1X//zxY///Hz/////////////+gs///QGj//0Fr//9Cbv//Q3H//0R0//9Fd///Rnr//0d+//9Igf//SYT//0qH//+ErvrNAAAAAAAAAAAAAAAAAAAAAL+/+EhBR/7+NDz//zU+//81Qv//NkX//zdI//84S///OU///zpR//87Vf//PFj//2mA///+/v//8/X//01v//9AaP//QWv//0Ju//9Dcf//RHT//0V3//9Gev//R37//0iB//9JhP//VpD+/sTV9UkAAAAAAAAAAAAAAAAAAAAAAAAAAImM+qk0PP7/NT7//zVC//82Rf//N0j//zhL//85T///OlH//ztV//88WP//PVv//83V//+hsv//P2T//0Bo//9Ba///Qm7//0Nx//9EdP//RXf//0Z6//9Hfv//SIH//0mE/v+Vt/uqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4eHwEWxy/Ns1Pv//NUL//zZF//83SP//OEv//zlP//86Uf//O1X//zxY//89W///SGf//0Jk//8/ZP//QGj//0Fr//9Cbv//Q3H//0R0//9Fd///Rnr//0d+//9Igf//e6P63PDw/xEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA19f4JmNr/Oc1Qv//NkX//zdI//84S///OU///zpR//87Vf//PFj//z1b//8+Xv//P2H//z9k//9AaP//QWv//0Ju//9Dcf//RHT//0V3//9Gev//R37//3Gc/OjR3vgnAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAz9b4JW12+9o2Rf7/N0j//zhL//85T///OlH//ztV//88WP//PVv//z5e//8/Yf//P2T//0Bo//9Ba///Qm7//0Nx//9EdP//RXf//0Z6/v94oPzb1uP4JQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4fD/EYqS+qhGVf7+OEv//zlP//86Uf//O1X//zxY//89W///Pl7//z9h//8/ZP//QGj//0Fr//9Cbv//Q3H//0R0//9Sgv7+kq/5qePj8RIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL7C+Ed3hPvLR1v9/zpR//87Vf//PFj//z1b//8+Xv//P2H//z9k//9AaP//QWv//0Ju//9Qe/3/f577y7/R9EgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADS2/Y5jp36kXOG+tliePz9TWj9/0Ji/v9DZf7/T3H9/2aF/P14lfvZk6n4ktPc8joAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANjr/w3o6Pks7fLyOu3y8jro7vksyNvtDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAADAAAABgAAAAAQAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB29v/B9/v7xDn5/MV6OjzFujo8xbn5/MV7+//EP///wcAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC/v/8E6PD4Is7U9U6frPh1ipv6koCU+6t7j/m5eY/6u3mR+rt8k/m5gpr7rIyi+pShtfh1zNb1UOPq8SW/v/8EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgID/At7e8k2tt/i4cIL75klh/vJGX//7Q1///kFd/v8+Xv7/Pl/+/z9g/v9AZP7/Q2f+/0dt//5Lcv/7T3b983OT/Oewwfe54OP2UoD//wIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANLS8BGyuPlTmqT4zF5v/P86Uf7/OlH//ztU//87Vv//PFj//z1a//89Xf//Pl7//z9g//8/Y///P2T//0Bn//9Baf//QWv//0Jt//9DcP7/Y4n8/5+1+dK2xflU19fyEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADU1P8Gy871SYWO+axcbP30PE/+/zlO//86UP//OlH//ztU//87Vv//PFj//z1a//89Xf//Pl7//z9g//8/Y///P2T//0Bn//9Baf//QWv//0Jt//9DcP//Q3H//0Z0/v9mjvz1jKn5sc7Y9U7U1P8GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN/f3wizufeHW2j97T1M//44Sv7/OEv//zlO//86UP//OlH//ztU//87Vv//PFj//z1a//89Xf//Pl7//z9g//8/Y///P2T//0Bn//9Baf//QWv//0Jt//9DcP//Q3H//0Rz//9Edv7/Snv//mOO/fC4y/iI1OrqDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAytT0GKes96JTXv39NkX+/zdH//84Sv//OEv//zlO//86UP//OlH//ztU//87Vv//PFj//z1a//89Xf//Pl7//z9g//8/Y///P2T//0Bn//9Baf//QWv//0Jt//9DcP//Q3H//0Rz//9Edv//RXf//0Z6/v9gjv39qcD3qdji9RoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADK0PMrjJL5tkhT/v42Q///NkX//zdH//84Sv//OEv//zlO//86UP//OlH//ztU//87Vv//PFj//z1a//89Xf//Pl7//z9g//8/Y///P2T//0Bn//9Baf//QWv//0Jt//9DcP//Q3H//0Rz//9Edv//RXf//0Z6//9GfP//V4r+/pS0+77Q2/MrAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANLS/xGKj/q9QEr+/DVB//82Q///NkX//zdH//84Sv//OEv//zlO//86UP//OlH//ztU//87Vv//PFj//z1a//89Xf//Pl7//z9g//8/Y///P2T//0Bn//9Baf//QWv//0Jt//9DcP//Q3H//0Rz//9Edv//RXf//0Z6//9GfP//R37//1CF/v2VtPq+2OL1GgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5ub/Cqmt+aFGTv7+NT7//zVB//84Rf//PEr//zdH//84Sv//OEv//zlO//86UP//OlH//ztU//87Vv//PFj//z1a//89Xf//Pl7//z9g//8/Y///P2T//0Bn//9Baf//QWv//0Jt//9DcP//Q3H//0Rz//9Edv//RXf//0p9//9Iff//R37//0iA//9Yjv7+qcP5qejo/wsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADU1NQGsbT3fVNZ/f00Pf//NT7//zVB//9ncf//p63//4GM//9QYP//Ok3//zlO//86UP//OlH//ztU//87Vv//PFj//z1a//89Xf//Pl7//z9g//8/Y///P2T//0Bn//9Baf//QWv//0Jt//9DcP//Q3H//0Rz//9Zhf//hab//6vD//9ym///R37//0iA//9Igv//YpX9/brP94bU1NQGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADNzfhMWV796TQ7/v80Pf//NT7//zVB//99hv//8/T///j5///p6///uL///2d3//87Uf//OlH//ztU//87Vv//PFj//z1a//89Xf//Pl7//z9g//8/Y///P2T//0Bn//9Baf//QWv//0Jt//9DcP//Z4z//7PG///p7///9/n///j5//+Hqv//R37//0iA//9Igv//SYT+/2aZ/e/R3vVNAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMTE6w2ChfmxO0H//jQ7//80Pf//NT7//zVB//9HU///1tn///////////////////39///U2f//iJb//1ds//9FX///PFn//z1a//89Xf//Pl7//z9g//8/Y///P2T//0Bn//9JcP//Wn///4Og///R3P//+/z//////////////////+Dp//9Vhv//R37//0iA//9Igv//SYT//0+K//6PtPux1+TyEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALm99UlZXf30Mzj+/zQ7//80Pf//NT7//zVB//82Q///hI3///7+/////////////////////////v7//+jr//+1v///Xnb//z1a//89Xf//Pl7//z9g//8/Y///P2T//1J1//+ywv//4+n///7+/////////////////////////v7//46u//9GfP//R37//0iA//9Igv//SYT//0qG/v9rnfz1t8/2VQAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/AZ6h+M41Of7/Mzj//zQ7//80Pf//NT7//zVB//82Q///O0r//9nc///////////////////////////////////+/v//xMz//z1a//89Xf//Pl7//z9g//8/Y///P2T//6i5///+/v//////////////////////////////////1+H//0p9//9GfP//R37//0iA//9Igv//SYT//0qG//9Miv7/osH50oCAgAIAAAAAAAAAAAAAAAAAAAAA3Nz4SFlc+/8yN///Mzj//zQ7//80Pf//NT7//zVB//82Q///NkX//3WA///6+v///////////////////////////////////f3//22E//89Xf//Pl7//z9g//8/Y///W3v///j6///////////////////////////////////5+v//f6L//0Z6//9GfP//R37//0iA//9Igv//SYT//0qG//9Kif//ap78/9/o9U8AAAAAAAAAAAAAAAD///8Dq6v4qjI2/v8yN///Mzj//zQ7//80Pf//NT7//zVB//82Q///NkX//0VU///R1f///v7//////////////////////////////////83U//9GZP//Pl7//z9g//9EZ///tsT///////////////////////////////////7+///L2f//VIP//0Z6//9GfP//R37//0iA//9Igv//SYT//0qG//9Kif//S4v+/7TN+Le/v78EAAAAAAAAAADq6vgka2382zI1//8yN///Mzj//zQ7//80Pf//NT7//zVB//82Q///NkX//zhI//+Pmf//+Pn///////////////////////////////////X2//94j///Pl7//z9g//9viv//7PD///////////////////////////////////j6//+Mqv//RXj//0Z6//9GfP//R37//0iA//9Igv//SYT//0qG//9Kif//S4r//3up++fq6vElAAAAAAAAAADGyfZRR0n97TI1//8yN///Mzj//zQ7//80Pf//NT7//zVB//82Q///NkX//zdH//9TY///3+L///////////////////////////////////7+//+3w///R2b//0Bh//+ktP///f7//////////////////////////////////+Hp//9Vgv//RXf//0Z6//9GfP//R37//0iA//9Igv//SYT//0qG//9Kif//S4r//1iV/vPQ3PlRAAAAAAAAAACdnfh1QkT++jI1//8yN///Mzj//zQ7//80Pf//NT7//zVB//82Q///NkX//zdH//84Sv//mqP////////////////////////////////////////t8P//Z4L//0Bh//+ltf///v7//////////////////////////////v7//5Cs//9Edv//RXf//0Z6//9GfP//R37//0iA//9Igv//SYT//0qG//9Kif//S4r//1WT//upxfl2AAD/AczM/wWFhvqUPT/+/jI1//8yN///Mzj//zQ7//80Pf//NT7//zVB//82Q///NkX//zdH//84Sv//Q1X//+rs///////////////////////////////////+/v//sb7//z9g//+Oo///+Pn/////////////////////////////2eL//0h2//9Edv//RXf//0Z6//9GfP//R37//0iA//9Igv//SYT//0qG//9Kif//S4r//1KS//6TufqV39/fCObm/wp6evuqNzn+/zI1//8yN///Mzj//zQ7//80Pf//NT7//zVB//82Q///NkX//zdH//84Sv//OEv//4qW///8/f//////////////////////////////////+Pn//1t4//9ohP//6u7////////////////////////5+v//gKD//0Rz//9Edv//RXf//0Z6//9GfP//R37//0iA//9Igv//SYT//0qG//9Kif//S4r//06P/v+JtPur3+/vENvb7Q51dfu3MzX+/zI1//8yN///Mzj//zQ7//80Pf//NT7//zVB//82Q///NkX//zdH//84Sv//OEv//0xe///d4f///////////////////////////////////////8HM//9Ob///w8////////////////////7+///N2f//VH7//0Rz//9Edv//RXf//0Z6//9GfP//R37//0iA//9Igv//SYT//0qG//9Kif//S4r//0yO/v+Gsfu45/PzFe3t/w5wcPu6MjT+/zI1//8yN///Mzj//zQ7//80Pf//NT7//zVB//82Q///NkX//zdH//84Sv//OEv//ztQ//+dqP///Pz///////////////////////////////////f5//+Hnf//Y4H///v7//////////////n6//+NqP//RHL//0Rz//9Edv//RXf//0Z6//9GfP//R37//0iA//9Igv//SYT//0qG//9Kif//S4r//0uN/v+Cr/u76PPzFu3t/w5wcPu6MjT+/zI1//8yN///Mzj//zQ7//80Pf//NT7//zVB//82Q///NkX//zdH//84Sv//OEv//zlO//9gcv//5un////////////////////////////////////////d5P//Y4H//6Cz///7/P///////+Lp//9Uff//Q3H//0Rz//9Edv//RXf//0Z6//9GfP//R37//0iA//9Igv//SYT//0qG//9Kif//S4r//0uN/v+Cr/u76PPzFtvb7Q51dfu3NDX+/zI1//8yN///Mzj//zQ7//80Pf//NT7//zVB//82Q///NkX//zdH//84Sv//OEv//zlO//88U///rbf////////////////////////////////////////+/v//0dr//26M///I0////P3//5Kr//9DcP//Q3H//0Rz//9Edv//RXf//0Z6//9GfP//R37//0iA//9Igv//SYT//0qG//9Kif//S4r//0yO/v+Gsfu45+fzFebm/wp6evqpODn+/zI1//8yN///Mzj//zQ7//80Pf//NT7//zVB//82Q///NkX//zdH//84Sv//OEv//zlO//86UP//TmP///X3/////////////////////////////////////////v7//+Po//+Env//tsb//0dx//9DcP//Q3H//0Rz//9Edv//RXf//0Z6//9GfP//R37//0iA//9Igv//SYT//0qG//9Kif//S4r//0+P/v+KtPuq3+/vEMzMzAWGhviTPj/+/jI1//8yN///Mzj//zQ7//80Pf//NT7//zVB//82Q///NkX//zdH//84Sv//OEv//zlO//86UP//OlH//6Cs///+/v/////////////////////////////////////////////f5v//XID//0Jt//9DcP//Q3H//0Rz//9Edv//RXf//0Z6//9GfP//R37//0iA//9Igv//SYT//0qG//9Kif//S4r//1KS//6UuvqU39/fCAAAAACdnfh1Q0T++jI1//8yN///Mzj//zQ7//80Pf//NT7//zVB//82Q///NkX//zdH//84Sv//OEv//zlO//86UP//OlH//1Vr///n6/////////////////////////////////////////7+///P2f//U3n//0Jt//9DcP//Q3H//0Rz//9Edv//RXf//0Z6//9GfP//R37//0iA//9Igv//SYT//0qG//9Kif//S4r//1WT//upxfl2AAD/AQAAAADOzvhOR0n+7DI1//8yN///Mzj//zQ7//80Pf//NT7//zVB//82Q///NkX//zdH//84Sv//OEv//zlO//86UP//OlH//z9X//+qtv///v7///////////////////////////////////n6//+Op///Q2z//0Jt//9DcP//Q3H//0Rz//9Edv//RXf//0Z6//9GfP//R37//0iA//9Igv//SYT//0qG//9Kif//S4r//1iV/fPS3/VPAAAAAAAAAADo6PchbXD72TI1//8yN///Mzj//zQ7//80Pf//NT7//zVB//82Q///NkX//zdH//84Sv//OEv//zlO//86UP//OlH//ztU//9tgf//7O///////////////////////////////////+Pp//9Uef//QWv//0Jt//9DcP//Q3H//0Rz//9Edv//RXf//0Z6//9GfP//R37//0iA//9Igv//SYT//0qG//9Kif//S4r//32q/OXo6PAiAAAAAAAAAACqqv8Dqqr2qDI2/v8yN///Mzj//zQ7//80Pf//NT7//zVB//82Q///NkX//zdH//84Sv//OEv//zlO//86UP//OlH//ztU//9CXP//vcb//////////////////////////////v7//5Wr//9Baf//QWv//0Jt//9DcP//Q3H//0Rz//9Edv//RXf//0Z6//9GfP//R37//0iA//9Igv//SYT//0qG//9Kif//S4v+/7PL97Wq//8DAAAAAAAAAAAAAAAA3NzzQl1f+/8yN///Mzj//zQ7//80Pf//NT7//zVB//82Q///NkX//zdH//84Sv//OEv//zlO//86UP//OlH//ztU//87Vv//Xnb///z8////////////////////////3uX//0Vr//9Baf//QWv//0Jt//9DcP//Q3H//0Rz//9Edv//RXf//0Z6//9GfP//R37//0iA//9Igv//SYT//0qG//9Kif//bJ/8/9/m9EgAAAAAAAAAAAAAAAAAAAAAAAD/AaGk+cY2Ov7/Mzj//zQ7//80Pf//NT7//zVB//82Q///NkX//zdH//84Sv//OEv//zlO//86UP//OlH//ztU//87Vv//PFj//7bB///+/v/////////////6+///g5z//0Bn//9Baf//QWv//0Jt//9DcP//Q3H//0Rz//9Edv//RXf//0Z6//9GfP//R37//0iA//9Igv//SYT//0qG//9Ni/7/o8H5y////wEAAAAAAAAAAAAAAAAAAAAAAAAAALy89EhZXf30Mzj+/zQ7//80Pf//NT7//zVB//82Q///NkX//zdH//84Sv//OEv//zlO//86UP//OlH//ztU//87Vv//PFj//2F4///v8v////////7+///Q2f//UnT//0Bn//9Baf//QWv//0Jt//9DcP//Q3H//0Rz//9Edv//RXf//0Z6//9GfP//R37//0iA//9Igv//SYT//0qG/v9rnfz1uc75VAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANHR/wuEh/msPEL//jQ7//80Pf//NT7//zVB//82Q///NkX//zdH//84Sv//OEv//zlO//86UP//OlH//ztU//87Vv//PFj//0Nf//+4w////v7///r7//+PpP//QWX//0Bn//9Baf//QWv//0Jt//9DcP//Q3H//0Rz//9Edv//RXf//0Z6//9GfP//R37//0iA//9Igv//SYT//0+K//6Rtfus0uHwEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADNzfRHXWP85jQ7/v80Pf//NT7//zVB//82Q///NkX//zdH//84Sv//OEv//zlO//86UP//OlH//ztU//87Vv//PFj//z1a//97kP//8fP//+Xp//9UdP//P2T//0Bn//9Baf//QWv//0Jt//9DcP//Q3H//0Rz//9Edv//RXf//0Z6//9GfP//R37//0iA//9Igv//SYT+/2ub/O3N3PRIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8FsbX3fFNa/P00Pf//NT7//zVB//82Q///NkX//zdH//84Sv//OEv//zlO//86UP//OlH//ztU//87Vv//PFj//z1a//9JZv//oLD//4Wb//8/Y///P2T//0Bn//9Baf//QWv//0Jt//9DcP//Q3H//0Rz//9Edv//RXf//0Z6//9GfP//R37//0iA//9Igv//YpX8/brP94XU1NQGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA29vbB6+y+JVIUP7+NT7//zVB//82Q///NkX//zdH//84Sv//OEv//zlO//86UP//OlH//ztU//87Vv//PFj//z1a//89Xf//QmL//0Bh//8/Y///P2T//0Bn//9Baf//QWv//0Jt//9DcP//Q3H//0Rz//9Edv//RXf//0Z6//9GfP//R37//0iA//9ajv7+rcX3nv///wcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMzM7g+Mkfm0Q0z++zVB//82Q///NkX//zdH//84Sv//OEv//zlO//86UP//OlH//ztU//87Vv//PFj//z1a//89Xf//Pl7//z9g//8/Y///P2T//0Bn//9Baf//QWv//0Jt//9DcP//Q3H//0Rz//9Edv//RXf//0Z6//9GfP//R37//1KH/vyVtvm1ytT0GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADT0/kpi5H5skhU/v42Q///NkX//zdH//84Sv//OEv//zlO//86UP//OlH//ztU//87Vv//PFj//z1a//89Xf//Pl7//z9g//8/Y///P2T//0Bn//9Baf//QWv//0Jt//9DcP//Q3H//0Rz//9Edv//RXf//0Z6//9GfP//V4r+/pOz+rvU2/MqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA29v/Dq2x9pNUYPz9NkX+/zdH//84Sv//OEv//zlO//86UP//OlH//ztU//87Vv//PFj//z1a//89Xf//Pl7//z9g//8/Y///P2T//0Bn//9Baf//QWv//0Jt//9DcP//Q3H//0Rz//9Edv//RXf//0Z6/v9ijvz9rcP3nM/f7xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANvb2wezt/d8YWz95UBP//44Sv7/OEv//zlO//86UP//OlH//ztU//87Vv//PFj//z1a//89Xf//Pl7//z9g//8/Y///P2T//0Bn//9Baf//QWv//0Jt//9DcP//Q3H//0Rz//9Edv7/TX3//miS/ei4yvd95v//CgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADMzP8Fy8/4RYaP+6tdbPz0PE/+/zlO//86UP//OlH//ztU//87Vv//PFj//z1a//89Xf//Pl7//z9g//8/Y///P2T//0Bn//9Baf//QWv//0Jt//9DcP//Q3H//0Z0/v9mjv30i6r5sM/Z+ErM//8FAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANHR/wu9xfhGoar4xGJz+/87Uf7/OlH//ztU//87Vv//PFj//z1a//89Xf//Pl7//z9g//8/Y///P2T//0Bn//9Baf//QWv//0Jt//9EcP7/Z4z7/6e8+cq+0PhH1Or/DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN7i9z6wufmld4f62VBn/exMZf36SGP+/kRg/v9AX/7/P2D+/0Bh/v9CZf7/Rmr+/0xw/v5Sdv76Vnv97XqX+tqyw/em3eX0RAAA/wEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8C5ub3H9TX9U2lsPh0jZ76kYOU+qd+kvu2epH6unuR+rqAlvu2hJv6qI6j+JOmt/h10tj5T+Ho8CKqqqoDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////BP///wnr6/8N7e3tDu3t7Q7r6/8N5ubmCszMzAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
    "hooks/useRealtimeSession.cl.jac": "# useRealtimeSession Hook\n# Custom hook for managing OpenAI Realtime API connection and session\n\nimport from react { useRef }\nimport from \"@openai/agents/realtime\" { RealtimeAgent, RealtimeSession, tool }\n\nimport from ..constants.constants { CHAT_AGENT_INSTRUCTIONS }\nimport from ..api.api {\n    getSessionToken,\n    callManager,\n    getUsernameFromToken\n}\n\ndef extractMessageText(content: any) -> str {\n    if not content or not content.length {\n        return \"\";\n    }\n    text = \"\";\n    for c in content {\n        if c and c.type == \"input_text\" {\n            text = text + (c.text or \"\");\n        } elif c and c.type == \"audio\" {\n            text = text + (c.transcript or \"\");\n        } elif c and c.type == \"text\" {\n            text = text + (c.text or \"\");\n        }\n    }\n    return text;\n}\n\n# Hook for managing OpenAI Realtime session\n# @param transcriptHelpers - Object containing transcript manipulation functions\n# @param refreshGraphState - Function to refresh graph state after supervisor calls\n# @param setSuggestions - Function to update suggestions state in parent\ndef:pub useRealtimeSession(transcriptHelpers: any, refreshGraphState: any, setSuggestions: any) -> any {\n    # Reactive state using has variables\n    has sessionStatus: str = \"DISCONNECTED\";\n\n    sessionRef = useRef(None);\n\n    # Computed values\n    isConnected = sessionStatus == \"CONNECTED\";\n    isConnecting = sessionStatus == \"CONNECTING\";\n        \n        # Destructure transcript helpers\n        addMessage = transcriptHelpers.addMessage;\n        addTranscriptItem = transcriptHelpers.addTranscriptItem;\n        updateTranscriptItem = transcriptHelpers.updateTranscriptItem;\n        appendTranscriptItem = transcriptHelpers.appendTranscriptItem;\n        \n        # ========== API Calls ==========\n        \n        # Fetch ephemeral key from backend for OpenAI Realtime API\n        async def fetchEphemeralKey() -> any {\n            try {\n                result = await getSessionToken();\n                console.log(\"Session response:\", result);\n                \n                if result.success {\n                    return result.key;\n                }\n                \n                console.error(\"Error fetching session:\", result.error);\n                return None;\n            } except Exception as e {\n                console.error(\"Error fetching ephemeral key:\", e);\n                return None;\n            }\n        }\n        \n        # ========== Supervisor Tool ==========\n        \n        # Execute supervisor tool - called by the Chat Agent\n        async def executeSupervisorTool(input: any, details: any) -> any {\n            context = input.relevantContextFromLastUserMessage or \"\";\n            history = details.context.history or [];\n\n            filteredHistory = history.filter(lambda log: any -> bool { return log.type == \"message\"; });\n\n            console.log(\"Calling supervisor with context:\", context);\n            \n            username = getUsernameFromToken();\n            console.log(\"Using username:\", username);\n\n            result = await callManager(context, filteredHistory, username);\n            console.log(\"Supervisor result:\", result);\n\n            if not result.success {\n                console.error(\"Supervisor error:\", result.error);\n                return {\"error\": \"Something went wrong.\"};\n            }\n\n            # Fetch updated graph state after supervisor completes\n            await refreshGraphState(username);\n            \n            # Update suggestions if available\n            if result.suggestions and Array.isArray(result.suggestions) {\n                setSuggestions(result.suggestions);\n            } else {\n                setSuggestions([]);\n            }\n\n            # Get response from service result\n            next_resp = result.response or \"I apologize, I couldn't get a response.\";\n            console.log(\"Returning nextResponse:\", next_resp);\n            return {\"nextResponse\": next_resp};\n        }\n        \n        # Create the supervisor tool for the Chat Agent\n        def createSupervisorTool() -> any {\n            return tool({\n                \"name\": \"getNextResponseFromSupervisor\",\n                \"description\": \"IMPORTANT: Before calling this tool, briefly acknowledge what the user just said you should log (e.g., a routine or next action) and tell them you're memorizing/noting it so there's no silent pause. Then call this tool to record/update and get the next response.\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"relevantContextFromLastUserMessage\": {\n                            \"type\": \"string\",\n                            \"description\": \"Key information from the user's most recent message.\"\n                        }\n                    },\n                    \"required\": [\"relevantContextFromLastUserMessage\"],\n                    \"additionalProperties\": False\n                },\n                \"execute\": executeSupervisorTool\n            });\n        }\n        \n        # ========== Session Event Listeners ==========\n        \n        def setupSessionEventListeners(session: any) -> None {\n            # Listen for history_added events (new messages)\n            session.on(\"history_added\", lambda item: any -> None {\n                console.log(\"[history_added]\", item);\n                if not item {\n                    return;\n                }\n                \n                if item.type == \"message\" {\n                    itemId = item.itemId or item.item_id or \"\";\n                    role = item.role or \"\";\n                    content = item.content or [];\n                    \n                    text = extractMessageText(content);\n                    \n                    if role == \"user\" and not text {\n                        text = \"[Transcribing...]\";\n                    }\n                    \n                    if role == \"assistant\" and not text {\n                        text = \"...\";\n                    }\n                    \n                    if role and itemId {\n                        addTranscriptItem(itemId, role, text);\n                    }\n                } elif item.type == \"function_call\" {\n                    itemId = item.itemId or item.item_id or \"\";\n                    toolName = item.name or \"tool\";\n                    addTranscriptItem(itemId, \"tool\", \"\ud83d\udd27 Calling: \" + toolName + \"...\");\n                }\n            });\n            \n            # Listen for history_updated events (message updates)\n            session.on(\"history_updated\", lambda items: any -> None {\n                console.log(\"[history_updated]\", items);\n                if not items or not items.length {\n                    return;\n                }\n                \n                for item in items {\n                    if not item {\n                        continue;\n                    }\n                    \n                    if item.type == \"message\" {\n                        itemId = item.itemId or item.item_id or \"\";\n                        role = item.role or \"\";\n                        content = item.content or [];\n                        \n                        text = extractMessageText(content);\n                        \n                        if text and itemId {\n                            addTranscriptItem(itemId, role, text);\n                            updateTranscriptItem(itemId, text);\n                        }\n                    } elif item.type == \"function_call\" {\n                        itemId = item.itemId or item.item_id or \"\";\n                        toolName = item.name or \"tool\";\n                        status = item.status or \"\";\n                        \n                        if status == \"completed\" {\n                            updateTranscriptItem(itemId, \"\u2713 \" + toolName + \" completed\");\n                        }\n                    }\n                }\n            });\n            \n            # Listen for transport events (audio transcription)\n            session.on(\"transport_event\", lambda event: any -> None {\n                eventType = event.type or \"\";\n                console.log(\"[transport_event]\", eventType, event);\n                \n                if eventType == \"conversation.item.input_audio_transcription.completed\" {\n                    itemId = event.item_id or \"\";\n                    transcriptText = event.transcript or \"[inaudible]\";\n                    if transcriptText == \"\\n\" {\n                        transcriptText = \"[inaudible]\";\n                    }\n                    console.log(\"[transcription completed]\", itemId, transcriptText);\n                    updateTranscriptItem(itemId, transcriptText);\n                } elif eventType == \"response.output_audio_transcript.delta\" {\n                    itemId = event.item_id or \"\";\n                    deltaText = event.delta or \"\";\n                    console.log(\"[transcript delta]\", itemId, deltaText);\n                    addTranscriptItem(itemId, \"assistant\", \"\");\n                    appendTranscriptItem(itemId, deltaText);\n                } elif eventType == \"response.output_audio_transcript.done\" {\n                    itemId = event.item_id or \"\";\n                    transcriptText = event.transcript or \"\";\n                    console.log(\"[transcript done]\", itemId, transcriptText);\n                    updateTranscriptItem(itemId, transcriptText);\n                }\n            });\n            \n            # Listen for tool calls\n            session.on(\"agent_tool_start\", lambda details: any, agent: any, functionCall: any -> None {\n                console.log(\"[tool start]\", functionCall);\n                toolName = functionCall.name or \"unknown\";\n                addMessage(\"tool\", f\"\ud83d\udd27 Calling: {toolName}...\");\n            });\n            \n            session.on(\"agent_tool_end\", lambda details: any, agent: any, functionCall: any, result: any -> None {\n                console.log(\"[tool end]\", functionCall, result);\n            });\n        }\n        \n        # ========== Connection Management ==========\n        \n        # Connect to OpenAI Realtime API with multi-agent setup\n        async def connectToRealtime() -> None {\n            if sessionStatus != \"DISCONNECTED\" {\n                return;\n            }\n            \n            sessionStatus = \"CONNECTING\";\n            \n            try {\n                if not window.isSecureContext {\n                    addMessage(\"error\", \"Microphone requires secure context. Access via http://localhost:8000\");\n                    sessionStatus = \"DISCONNECTED\";\n                    return;\n                }\n                \n                if not navigator.mediaDevices {\n                    addMessage(\"error\", \"MediaDevices API not available.\");\n                    sessionStatus = \"DISCONNECTED\";\n                    return;\n                }\n                \n                api_key = await fetchEphemeralKey();\n                \n                if not api_key {\n                    console.error(\"No ephemeral key received\");\n                    sessionStatus = \"DISCONNECTED\";\n                    return;\n                }\n                \n                console.log(\"Got ephemeral key, creating multi-agent setup...\");\n                \n                supervisorTool = createSupervisorTool();\n                \n                chatAgentConfig = {\n                    \"name\": \"chatAgent\",\n                    \"voice\": \"sage\",\n                    \"instructions\": CHAT_AGENT_INSTRUCTIONS,\n                    \"tools\": [supervisorTool]\n                };\n                chatAgent = Reflect.construct(RealtimeAgent, [chatAgentConfig]);\n\n                console.log(\"Chat Agent created with supervisor tool\");\n\n                session = Reflect.construct(RealtimeSession, [chatAgent]);\n                \n                console.log(\"Session created, setting up event listeners...\");\n                \n                # Set up session event listeners\n                setupSessionEventListeners(session);\n                \n                console.log(\"Connecting to OpenAI...\");\n                \n                await session.connect({\"apiKey\": api_key});\n                \n                console.log(\"Successfully connected to OpenAI Realtime API with multi-agent setup!\");\n                sessionRef.current = session;\n                sessionStatus = \"CONNECTED\";\n\n                # Load user's existing graph when they connect\n                username = getUsernameFromToken();\n                console.log(\"Loading graph for username:\", username);\n                await refreshGraphState(username);\n\n                addMessage(\"system\", \"Connected! Algo is ready. Say 'hi' to start!\");\n                \n            } except Exception as e {\n                console.error(\"Connection error:\", e);\n                if e and e.message {\n                    console.error(\"Error message:\", e.message);\n                }\n                sessionStatus = \"DISCONNECTED\";\n            }\n        }\n        \n        # Disconnect from OpenAI Realtime API\n        def disconnectFromRealtime(resetPTTState: any) -> None {\n            if sessionRef.current {\n                console.log(\"Disconnecting session...\");\n                sessionRef.current.close();\n                sessionRef.current = None;\n            }\n            sessionStatus = \"DISCONNECTED\";\n            if resetPTTState {\n                resetPTTState();\n            }\n        }\n        \n        # Toggle connection state\n        def onToggleConnection(resetPTTState: any) -> None {\n            if sessionStatus == \"CONNECTED\" or sessionStatus == \"CONNECTING\" {\n                disconnectFromRealtime(resetPTTState);\n            } else {\n                connectToRealtime();\n            }\n        }\n        \n        # Send message via realtime session\n        def sendRealtimeMessage(message: str) -> bool {\n            if sessionRef.current and sessionStatus == \"CONNECTED\" {\n                try {\n                    sessionRef.current.sendMessage(message);\n                    return True;\n                } except Exception as e {\n                    console.error(\"Failed to send via realtime:\", e);\n                    return False;\n                }\n            }\n            return False;\n        }\n        \n        return {\n            # State\n            \"sessionStatus\": sessionStatus,\n            \"sessionRef\": sessionRef,\n            \n            # Computed\n            \"isConnected\": isConnected,\n            \"isConnecting\": isConnecting,\n            \n            # Handlers\n            \"connectToRealtime\": connectToRealtime,\n            \"disconnectFromRealtime\": disconnectFromRealtime,\n        \"onToggleConnection\": onToggleConnection,\n        \"sendRealtimeMessage\": sendRealtimeMessage\n    };\n}",
    "hooks/useHead.cl.jac": "# useHead Hook\n# Manage document head metadata (title, description, favicon, etc.)\n\n# Default meta configuration\nglob:pub DEFAULT_META = {\n    \"title\": \"Algo\",\n    \"description\": \"Your Personal AI Assistant with Voice Interface\",\n    \"favicon\": \"/static/assets/favicon.ico\",\n    \"themeColor\": \"#ff7743\",\n    \"ogImage\": \"/static/assets/og-image.png\"\n};\n\ndef:pub useHead(config: any) -> None {\n    # Using new can with [dep] entry syntax\n    can with [config] entry {\n        # Title\n        if config and config.title {\n            document.title = config.title;\n        }\n\n        # Helper to set or create meta tag\n        def setMeta(name: str, content: str, isProperty: bool) -> None {\n            attr = \"property\" if isProperty else \"name\";\n            selector = f'meta[{attr}=\"{name}\"]';\n            existing = document.querySelector(selector);\n\n            if existing {\n                existing.content = content;\n            } else {\n                meta = document.createElement('meta');\n                meta.setAttribute(attr, name);\n                meta.content = content;\n                document.head.appendChild(meta);\n            }\n        }\n\n        # Helper to set or create link tag\n        def setLink(rel: str, href: str) -> None {\n            selector = f'link[rel=\"{rel}\"]';\n            existing = document.querySelector(selector);\n\n            if existing {\n                existing.href = href;\n            } else {\n                link = document.createElement('link');\n                link.rel = rel;\n                link.href = href;\n                document.head.appendChild(link);\n            }\n        }\n\n        # Viewport (mobile support)\n        setMeta(\"viewport\", \"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\", False);\n\n        # Description\n        if config and config.description {\n            setMeta(\"description\", config.description, False);\n        }\n\n        # Theme color (for mobile browsers)\n        if config and config.themeColor {\n            setMeta(\"theme-color\", config.themeColor, False);\n        }\n\n        # Favicon\n        if config and config.favicon {\n            setLink(\"icon\", config.favicon);\n        }\n\n        # Open Graph tags (for social sharing)\n        if config and config.title {\n            setMeta(\"og:title\", config.title, True);\n        }\n        if config and config.description {\n            setMeta(\"og:description\", config.description, True);\n        }\n        if config and config.ogImage {\n            setMeta(\"og:image\", config.ogImage, True);\n        }\n\n        # Twitter Card\n        setMeta(\"twitter:card\", \"summary_large_image\", False);\n    }\n}\n",
    "hooks/useAudioControls.cl.jac": "# useAudioControls Hook\n# Custom hook for managing audio, microphone, and push-to-talk controls\n\nimport from react { useRef }\n\ndef:pub useAudioControls(sessionRef: any, sessionStatus: str) -> any {\n    # Audio element ref\n    audioElementRef = useRef(None);\n\n    # Reactive state using has variables\n    has isPTTActive: bool = False;\n    has isPTTUserSpeaking: bool = False;\n    has isAudioPlaybackEnabled: bool = True;\n    has isMicMuted: bool = False;\n\n    # Toggle mic mute state\n    def toggleMicMute() -> None {\n        isMicMuted = not isMicMuted;\n    }\n\n    # Push-to-Talk: Button down handler\n    def handleTalkButtonDown() -> None {\n        if sessionStatus != \"CONNECTED\" {\n            return;\n        }\n        isPTTUserSpeaking = True;\n\n        if sessionRef.current {\n            try {\n                sessionRef.current.interrupt();\n            } except Exception as e {\n                console.error(\"PTT error:\", e);\n            }\n        }\n    }\n\n    # Push-to-Talk: Button up handler\n    def handleTalkButtonUp() -> None {\n        if sessionStatus != \"CONNECTED\" or not isPTTUserSpeaking {\n            return;\n        }\n        isPTTUserSpeaking = False;\n    }\n\n    # Reset PTT state (called on disconnect)\n    def resetPTTState() -> None {\n        isPTTUserSpeaking = False;\n    }\n\n    # Setter wrapper functions for parent components\n    def updatePTTActive(value: bool) -> None {\n        isPTTActive = value;\n    }\n\n    def updateAudioPlaybackEnabled(value: bool) -> None {\n        isAudioPlaybackEnabled = value;\n    }\n\n    # Create audio element on mount - using new can with entry syntax\n    can with entry {\n        el = document.createElement('audio');\n        el.autoplay = True;\n        el.style.display = 'none';\n        document.body.appendChild(el);\n        audioElementRef.current = el;\n    }\n\n    # Handle mic mute/unmute - using new can with (deps) entry syntax\n    can with (isMicMuted, sessionStatus) entry {\n        if sessionRef.current {\n            try {\n                console.log(\"Setting mic mute state to:\", isMicMuted);\n                sessionRef.current.mute(isMicMuted);\n            } except Exception as e {\n                console.error(\"Error toggling mic:\", e);\n            }\n        }\n    }\n\n    # Audio playback toggle - using new can with [dep] entry syntax\n    can with [isAudioPlaybackEnabled] entry {\n        if audioElementRef.current {\n            audioElementRef.current.muted = not isAudioPlaybackEnabled;\n        }\n    }\n    \n    return {\n        # State\n        \"isPTTActive\": isPTTActive,\n        \"setIsPTTActive\": updatePTTActive,\n        \"isPTTUserSpeaking\": isPTTUserSpeaking,\n        \"isAudioPlaybackEnabled\": isAudioPlaybackEnabled,\n        \"setIsAudioPlaybackEnabled\": updateAudioPlaybackEnabled,\n        \"isMicMuted\": isMicMuted,\n\n        # Refs\n        \"audioElementRef\": audioElementRef,\n\n        # Handlers\n        \"toggleMicMute\": toggleMicMute,\n        \"handleTalkButtonDown\": handleTalkButtonDown,\n        \"handleTalkButtonUp\": handleTalkButtonUp,\n        \"resetPTTState\": resetPTTState\n    };\n}\n",
    "hooks/useAuth.cl.jac": "import from \"@jac/runtime\" { jacLogin, jacSignup, useNavigate }\n\ndef:pub useAuth() -> any {\n    navigate = useNavigate();\n\n    # Reactive state using has variables\n    # Shared State\n    has username: str = \"\";\n    has password: str = \"\";\n    has error: str = \"\";\n    has loading: bool = False;\n\n    # Register-Specific State\n    has confirmPassword: str = \"\";\n\n    # Shared Input Handlers\n\n    def handleUsernameChange(e: any) -> None {\n        username = e.target.value;\n    }\n\n    def handlePasswordChange(e: any) -> None {\n        password = e.target.value;\n    }\n\n    def handleConfirmPasswordChange(e: any) -> None {\n        confirmPassword = e.target.value;\n    }\n\n    # Login Handler\n    async def handleLogin(e: any) -> None {\n        e.preventDefault();\n        error = \"\";\n\n        # Validation\n        if not username or not password {\n            error = \"Please fill in all fields\";\n            return;\n        }\n\n        loading = True;\n\n        try {\n            success = await jacLogin(username, password);\n            if success {\n                navigate(\"/\");\n            } else {\n                error = \"Invalid username or password\";\n            }\n        } except Exception as ex {\n            console.error(\"Login error:\", ex);\n            if ex.message {\n                error = ex.message;\n            } else {\n                error = \"An error occurred during login\";\n            }\n        } finally {\n            loading = False;\n        }\n    }\n\n    # Register Handler\n    async def handleRegister(e: any) -> None {\n        e.preventDefault();\n        error = \"\";\n\n        # Validation\n        if not username or not password or not confirmPassword {\n            error = \"Please fill in all fields\";\n            return;\n        }\n\n        if password != confirmPassword {\n            error = \"Passwords do not match\";\n            return;\n        }\n\n        if password.length < 6 {\n            error = \"Password must be at least 6 characters\";\n            return;\n        }\n\n        loading = True;\n\n        try {\n            result = await jacSignup(username, password);\n            if result[\"success\"] {\n                # Auto-login after successful registration\n                navigate(\"/\");\n            } else {\n                # Extract message from error object\n                errorData = result[\"error\"];\n                if errorData and errorData.message {\n                    error = errorData.message;\n                } else {\n                    error = \"Registration failed\";\n                }\n            }\n        } except Exception as ex {\n            console.error(\"Registration error:\", ex);\n            if ex.message {\n                error = ex.message;\n            } else {\n                error = \"An error occurred during registration\";\n            }\n        } finally {\n            loading = False;\n        }\n    }\n\n    # Return Hook Interface\n    return {\n        \"username\": username,\n        \"password\": password,\n        \"error\": error,\n        \"loading\": loading,\n\n        \"confirmPassword\": confirmPassword,\n\n        \"handleUsernameChange\": handleUsernameChange,\n        \"handlePasswordChange\": handlePasswordChange,\n        \"handleConfirmPasswordChange\": handleConfirmPasswordChange,\n\n        \"handleLogin\": handleLogin,\n        \"handleRegister\": handleRegister\n    };\n}",
    "hooks/useMainApp.cl.jac": "# useMainApp Hook\n# Main orchestrator hook that composes all sub-hooks\n# Provides a unified interface for the MainApp component\n\nimport from react { useRef }\nimport from \"@jac/runtime\" { useNavigate }\n\n# Import sub-hooks\nimport from .useTranscript { useTranscript }\nimport from .useGraph { useGraph }\nimport from .useRealtimeSession { useRealtimeSession }\nimport from .useAudioControls { useAudioControls }\n\n# Import services\nimport from ..api.api {\n    callManager,\n    saveRoutine,\n    getUsernameFromToken\n}\n\ndef:pub useMainApp() -> any {\n    navigate = useNavigate();\n\n    # ========== Local State ==========\n    # Reactive state using has variables\n    has userText: str = \"\";\n    has suggestions: list = [];\n\n    # Ref for auto-scroll\n    transcriptEndRef = useRef(None);\n    \n    # ========== Compose Sub-Hooks ==========\n    \n    # Transcript management\n    transcriptHook = useTranscript();\n    transcript = transcriptHook.transcript;\n    addMessage = transcriptHook.addMessage;\n    addTranscriptItem = transcriptHook.addTranscriptItem;\n    updateTranscriptItem = transcriptHook.updateTranscriptItem;\n    appendTranscriptItem = transcriptHook.appendTranscriptItem;\n    clearTranscript = transcriptHook.clearTranscript;\n    \n    # Create transcript helpers object for other hooks\n    transcriptHelpers = {\n        \"addMessage\": addMessage,\n        \"addTranscriptItem\": addTranscriptItem,\n        \"updateTranscriptItem\": updateTranscriptItem,\n        \"appendTranscriptItem\": appendTranscriptItem\n    };\n    \n    # Graph state management\n    graphHook = useGraph(addMessage);\n    graphDotCode = graphHook.graphDotCode;\n    graphEdges = graphHook.graphEdges;\n    lastTask = graphHook.lastTask;\n    refreshGraphState = graphHook.refreshGraphState;\n    handleClearGraph = graphHook.handleClearGraph;\n    \n    # Create a setter function wrapper for suggestions to pass to child hooks\n    def updateSuggestions(newSuggestions: list) -> None {\n        suggestions = newSuggestions;\n    }\n\n    # Realtime session management (pass updateSuggestions)\n    sessionHook = useRealtimeSession(transcriptHelpers, refreshGraphState, updateSuggestions);\n    sessionStatus = sessionHook.sessionStatus;\n    sessionRef = sessionHook.sessionRef;\n    isConnected = sessionHook.isConnected;\n    isConnecting = sessionHook.isConnecting;\n    sendRealtimeMessage = sessionHook.sendRealtimeMessage;\n    \n    # Audio controls\n    audioHook = useAudioControls(sessionRef, sessionStatus);\n    isPTTActive = audioHook.isPTTActive;\n    setIsPTTActive = audioHook.setIsPTTActive;\n    isPTTUserSpeaking = audioHook.isPTTUserSpeaking;\n    isAudioPlaybackEnabled = audioHook.isAudioPlaybackEnabled;\n    setIsAudioPlaybackEnabled = audioHook.setIsAudioPlaybackEnabled;\n    isMicMuted = audioHook.isMicMuted;\n    toggleMicMute = audioHook.toggleMicMute;\n    handleTalkButtonDown = audioHook.handleTalkButtonDown;\n    handleTalkButtonUp = audioHook.handleTalkButtonUp;\n    resetPTTState = audioHook.resetPTTState;\n    \n    # ========== Enhanced State Setters ==========\n\n    # Wrap userText change to clear suggestions when user starts typing\n    def handleUserTextChange(newText: str) -> None {\n        userText = newText;\n        # Clear suggestions if user is typing (not empty)\n        if newText and suggestions.length > 0 {\n            suggestions = [];\n        }\n    }\n    \n    # ========== Connection Handlers ==========\n    \n    def onToggleConnection() -> None {\n        sessionHook.onToggleConnection(resetPTTState);\n    }\n    \n    # ========== Message Handling ==========\n    \n    # Send text message (text-only chat or via voice session)\n    async def handleSendTextMessage() -> None {\n        message = userText.trim();\n        if not message {\n            return;\n        }\n\n        userText = \"\";\n        suggestions = [];  # Clear suggestions when sending\n        addMessage(\"user\", message);\n\n        username = getUsernameFromToken();\n\n        # If connected to realtime session, send via voice\n        if sendRealtimeMessage(message) {\n            return;\n        }\n\n        # Text-only mode: call supervisor directly using service layer\n        try {\n            assistantItemId = \"assistant-\" + String(Date.now());\n            addTranscriptItem(assistantItemId, \"assistant\", \"Thinking...\");\n\n            console.log(\"Calling supervisor with message:\", message, \"username:\", username);\n            result = await callManager(message, [], username);\n            console.log(\"Supervisor result:\", result);\n            if result.success {\n                # Pass thinking data if available\n                thinkingData = None;\n                if result.thinking {\n                    console.log(\"Found thinking data:\", result.thinking);\n                    thinkingData = result.thinking;\n                }\n                console.log(\"Updating transcript with thinking:\", thinkingData);\n                updateTranscriptItem(assistantItemId, result.response, thinkingData);\n                await refreshGraphState(username);\n\n                # Update suggestions if available\n                if result.suggestions and Array.isArray(result.suggestions) {\n                    suggestions = result.suggestions;\n                } else {\n                    suggestions = [];\n                }\n            } else {\n                updateTranscriptItem(assistantItemId, \"Error: \" + (result.error or \"Unknown error\"));\n                suggestions = [];\n            }\n        } except Exception as e {\n            console.error(\"Text chat error:\", e);\n            addMessage(\"system\", \"Error: Failed to get response\");\n            suggestions = [];\n        }\n    }\n    \n    # Handle suggestion click - auto-send the suggestion\n    async def handleSuggestionClick(suggestionText: str) -> None {\n        userText = suggestionText;\n        suggestions = [];  # Clear suggestions immediately\n        addMessage(\"user\", suggestionText);\n\n        username = getUsernameFromToken();\n\n        # If connected to realtime session, send via voice\n        if sendRealtimeMessage(suggestionText) {\n            return;\n        }\n\n        # Text-only mode: call supervisor\n        try {\n            assistantItemId = \"assistant-\" + String(Date.now());\n            addTranscriptItem(assistantItemId, \"assistant\", \"Thinking...\");\n\n            result = await callManager(suggestionText, [], username);\n            if result.success {\n                # Pass thinking data if available\n                thinkingData = None;\n                if result.thinking {\n                    console.log(\"Found thinking data from suggestion:\", result.thinking);\n                    thinkingData = result.thinking;\n                }\n                console.log(\"Updating transcript with thinking:\", thinkingData);\n                updateTranscriptItem(assistantItemId, result.response, thinkingData);\n                await refreshGraphState(username);\n\n                # Update suggestions if available\n                if result.suggestions and Array.isArray(result.suggestions) {\n                    suggestions = result.suggestions;\n                } else {\n                    suggestions = [];\n                }\n            } else {\n                updateTranscriptItem(assistantItemId, \"Error: \" + (result.error or \"Unknown error\"));\n                suggestions = [];\n            }\n        } except Exception as e {\n            console.error(\"Suggestion click error:\", e);\n            addMessage(\"system\", \"Error: Failed to get response\");\n            suggestions = [];\n        }\n    }\n    \n    # ========== Routine Management ==========\n    \n    # Save current routine and restart session\n    async def handleSaveAndRestart() -> None {\n        if sessionStatus != \"CONNECTED\" {\n            return;\n        }\n        \n        try {\n            username = getUsernameFromToken();\n            \n            result = await saveRoutine(\"daily_routine\", username);\n            console.log(\"Save routine response:\", result);\n            \n            if result.success {\n                addMessage(\"system\", \"Routine saved! Restarting session...\");\n                \n                clearTranscript();\n                \n                setTimeout(lambda -> None {\n                    addMessage(\"assistant\", \"Welcome back! I remember your routine. How can I help you today?\");\n                }, 500);\n            } else {\n                addMessage(\"error\", \"Failed to save routine: \" + (result.error or \"Unknown error\"));\n            }\n        } except Exception as e {\n            console.error(\"Save and restart error:\", e);\n            addMessage(\"error\", \"Error during save and restart\");\n        }\n    }\n    \n    # ========== Effects ==========\n\n    # Auto-scroll to bottom when transcript changes - using new can with [dep] entry syntax\n    can with [transcript] entry {\n        if transcriptEndRef.current {\n            transcriptEndRef.current.scrollIntoView({\"behavior\": \"smooth\"});\n        }\n    }\n    \n    # ========== Return Hook Interface ==========\n    return {\n        # State\n        \"sessionStatus\": sessionStatus,\n        \"isPTTActive\": isPTTActive,\n        \"setIsPTTActive\": setIsPTTActive,\n        \"isPTTUserSpeaking\": isPTTUserSpeaking,\n        \"isAudioPlaybackEnabled\": isAudioPlaybackEnabled,\n        \"setIsAudioPlaybackEnabled\": setIsAudioPlaybackEnabled,\n        \"isMicMuted\": isMicMuted,\n        \"userText\": userText,\n        \"setUserText\": handleUserTextChange,  # Use wrapped version\n        \"transcript\": transcript,\n        \"graphDotCode\": graphDotCode,\n        \"graphEdges\": graphEdges,\n        \"lastTask\": lastTask,\n        \"suggestions\": suggestions,\n\n        # Refs\n        \"transcriptEndRef\": transcriptEndRef,\n\n        # Computed\n        \"isConnected\": isConnected,\n        \"isConnecting\": isConnecting,\n\n        # Handlers\n        \"onToggleConnection\": onToggleConnection,\n        \"toggleMicMute\": toggleMicMute,\n        \"handleTalkButtonDown\": handleTalkButtonDown,\n        \"handleTalkButtonUp\": handleTalkButtonUp,\n        \"handleSendTextMessage\": handleSendTextMessage,\n        \"handleSuggestionClick\": handleSuggestionClick,\n        \"handleClearGraph\": handleClearGraph,\n        \"handleSaveAndRestart\": handleSaveAndRestart\n    };\n}",
    "hooks/useGraph.cl.jac": "# useGraph Hook\n# Custom hook for managing task graph state and operations\n\nimport from ..api.api {\n    getTaskGraph,\n    clearTaskGraph,\n    getUsernameFromToken\n}\n\ndef:pub useGraph(addMessage: any) -> any {\n    # Reactive state using has variables\n    has graphDotCode: str = \"\";\n    has graphEdges: list = [];\n    has lastTask: str = \"Start\";\n\n    # Fetch and update graph state from backend using service layer\n    async def refreshGraphState(username: str) -> None {\n        try {\n            result = await getTaskGraph(username);\n            console.log(\"Fetched updated graph:\", result);\n\n            if result.success and result.data {\n                graph_data = result.data;\n                console.log(\"Graph data received:\", graph_data);\n\n                if graph_data.dotCode != None {\n                    newDotCode = String(graph_data.dotCode);\n                    console.log(\"Setting new DOT code, length:\", newDotCode.length);\n                    graphDotCode = newDotCode;\n                }\n                if graph_data.edges != None {\n                    newEdges = Array.from(graph_data.edges);\n                    console.log(\"Setting new edges, count:\", newEdges.length);\n                    graphEdges = newEdges;\n                }\n                if graph_data.lastTask {\n                    lastTask = graph_data.lastTask;\n                }\n            } else {\n                console.error(\"Failed to fetch graph:\", result.error);\n            }\n        } except Exception as graph_error {\n            console.error(\"Failed to fetch updated graph:\", graph_error);\n        }\n    }\n\n    # Clear the task graph using service layer\n    async def handleClearGraph() -> None {\n        try {\n            username = getUsernameFromToken();\n\n            result = await clearTaskGraph(username);\n            console.log(\"Clear graph response:\", result);\n\n            if result.success {\n                data = result.data;\n                graphDotCode = data.dotCode or \"\";\n                graphEdges = data.edges or [];\n                lastTask = data.lastTask or \"Start\";\n\n                addMessage(\"system\", \"Graph cleared! Starting fresh.\");\n            } else {\n                addMessage(\"error\", \"Failed to clear graph\");\n            }\n        } except Exception as e {\n            console.error(\"Clear graph error:\", e);\n            addMessage(\"error\", \"Error clearing graph\");\n        }\n    }\n\n    return {\n        \"graphDotCode\": graphDotCode,\n        \"graphEdges\": graphEdges,\n        \"lastTask\": lastTask,\n        \"refreshGraphState\": refreshGraphState,\n        \"handleClearGraph\": handleClearGraph\n    };\n}",
    "hooks/useTranscript.cl.jac": "# useTranscript Hook\n# Custom hook for managing transcript state and operations\n\ndef:pub useTranscript() -> any {\n    # Reactive state using has variables\n    has transcript: list = [];\n\n    # Add a new message to transcript (for system messages)\n    def addMessage(role: str, content: str) -> None {\n        itemId = \"msg-\" + String(Date.now());\n        newItem = {\"itemId\": itemId, \"role\": role, \"content\": content, \"timestamp\": Date.now()};\n        transcript = lambda prev: any -> any { return prev.concat([newItem]); };\n    }\n\n    # Add a transcript item by itemId (for realtime messages)\n    def addTranscriptItem(itemId: str, role: str, content: str, thinking: any = None) -> None {\n        newItem = {\"itemId\": itemId, \"role\": role, \"content\": content, \"thinking\": thinking, \"timestamp\": Date.now()};\n        transcript = lambda prev: any -> any {\n            exists = prev.some(lambda item: any -> bool { return item.itemId == itemId; });\n            if exists {\n                return prev;\n            }\n            return prev.concat([newItem]);\n        };\n    }\n\n    # Update a transcript item by itemId\n    def updateTranscriptItem(itemId: str, content: str, thinking: any = None) -> None {\n        transcript = lambda prev: any -> any {\n            return prev.map(lambda item: any -> any {\n                if item.itemId == itemId {\n                    updatedItem = {\"itemId\": item.itemId, \"role\": item.role, \"content\": content, \"timestamp\": item.timestamp};\n                    # Add thinking data if provided or preserve existing\n                    thinkingValue = thinking if thinking != None else (item.thinking if item.thinking else None);\n                    if thinkingValue != None {\n                        updatedItem[\"thinking\"] = thinkingValue;\n                    }\n                    return updatedItem;\n                }\n                return item;\n            });\n        };\n    }\n\n    # Append text to a transcript item by itemId (for streaming)\n    def appendTranscriptItem(itemId: str, deltaText: str) -> None {\n        transcript = lambda prev: any -> any {\n            return prev.map(lambda item: any -> any {\n                if item.itemId == itemId {\n                    currentContent = item.content or \"\";\n                    newContent = currentContent + deltaText;\n                    if currentContent == \"...\" or currentContent == \"\" {\n                        newContent = deltaText;\n                    }\n                    updatedItem = {\"itemId\": item.itemId, \"role\": item.role, \"content\": newContent, \"timestamp\": item.timestamp};\n                    # Preserve thinking data if it exists\n                    thinkingValue = item.thinking if item.thinking else None;\n                    if thinkingValue != None {\n                        updatedItem[\"thinking\"] = thinkingValue;\n                    }\n                    return updatedItem;\n                }\n                return item;\n            });\n        };\n    }\n\n    # Clear transcript\n    def clearTranscript() -> None {\n        transcript = [];\n    }\n\n    return {\n        \"transcript\": transcript,\n        \"addMessage\": addMessage,\n        \"addTranscriptItem\": addTranscriptItem,\n        \"updateTranscriptItem\": updateTranscriptItem,\n        \"appendTranscriptItem\": appendTranscriptItem,\n        \"clearTranscript\": clearTranscript\n    };\n}\n",
    "constants/constants.cl.jac": "glob:pub CHAT_AGENT_INSTRUCTIONS = \"\"\"You are Algo - a friendly AI companion helping people organize their lives through conversation.\n\n# Your Role\n- Welcome warmly: \"Hey! I'm Algo, your personal AI companion. What are you up to?\"\n- Handle simple greetings, thanks, small talk naturally\n- **CRITICAL**: You MUST call getNextResponseFromSupervisor for ANY user message about activities, tasks, plans, or routines even\nif it is the first message in the conversation.\n\n# When to Call getNextResponseFromSupervisor (ALWAYS)\nYou MUST call this tool when the user mentions:\n- Activities they're doing: \"I'm making coffee\", \"checking email\", \"going to gym\"\n- Plans they have: \"I'll do X\", \"I'm planning to Y\", \"I need to Z\"\n- Sequences of tasks: \"First X, then Y\", \"After A, I'll B\"\n- Corrections to tasks: \"Actually...\", \"No, I meant...\", \"Before X\"\n- Questions about their routine: \"What's next?\", \"What did I say?\"\n- Time-related activities: \"in the morning\", \"after lunch\", \"tonight\"\n- Conditional tasks: \"if it rains\", \"otherwise\", \"either way\"\n\n# When NOT to Call (ONLY these cases)\n- Pure greetings: \"hi\", \"hello\", \"hey\" (respond warmly without tool)\n- Pure thanks: \"thank you\", \"thanks\" (respond without tool)\n- Pure goodbyes: \"bye\", \"goodbye\", \"see you\" (respond without tool)\n\n**DEFAULT RULE**: If unsure, CALL THE TOOL. Better to call unnecessarily than to miss logging a task.\n\n# Voice-Friendly Responses\nBefore calling backend, use natural filler:\n- \"Let me check that for you...\"\n- \"One moment, pulling that up...\"\n- \"Looking into that...\"\n\nKeep responses conversational:\n\u2705 \"Got it, making coffee!\"\n\u274c \"Acknowledged. Processing.\"\n\nNo technical terms, parentheses, or code formatting in responses.\n\"\"\";\n"
  },
  "directories": [
    ".jac"
  ],
  "gitignore_entries": [
    "*"
  ],
  "root_gitignore_entries": [
    ".jac/"
  ],
  "jaclang": "0.9.11",
  "plugins": [
    {
      "name": "jac-client",
      "version": "0.2.11"
    }
  ]
}